{"version":3,"sources":["webpack://zeta/webpack/universalModuleDefinition","webpack://zeta/./src/env.js","webpack://zeta/./src/shim.js","webpack://zeta/./src/util.js","webpack://zeta/./src/domUtil.js","webpack://zeta/./src/cssUtil.js","webpack://zeta/./src/events.js","webpack://zeta/./src/domLock.js","webpack://zeta/./src/dom.js","webpack://zeta/./src/index.js","webpack://zeta/external \"promise-polyfill\"","webpack://zeta/external {\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\",\"root\":\"$\"}","webpack://zeta/webpack/bootstrap","webpack://zeta/webpack/runtime/define property getters","webpack://zeta/webpack/runtime/hasOwnProperty shorthand","webpack://zeta/webpack/runtime/make namespace object","webpack://zeta/webpack/startup"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;;AAEO;AACA;AACA;AACA;AACA;;;ACPP;;AAEA,MAAM,QAAG;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,MAAM,YAAO;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,mBAAmB,UAAc;AACjC,+CAA+C,mBAAO,CAAC,EAAQ;AAC/D,MAAM,YAAO,oCAAoC,gCAAmC;;AAQlF;;;AC5MgD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,yBAAyB,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,YAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,qDAAqD,GAAG;AACxD;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,WAAW,oBAAe;AAC1B;;AAEA;AACA,WAAW,mBAAc;AACzB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA,eAAe,oBAAe;AAC9B;AACA,uBAAuB,YAAO;AAC9B;AACA;AACA;AACA,eAAe,gBAAW;AAC1B;AACA,SAAS;AACT;AACA;AACA,WAAW,gBAAW;AACtB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,YAAO;AACtB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;AAGA;AACA;AACA;;AAEA,SAAS,mBAAc;AACvB;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA,KAAK;AACL;AACA;;AAEA;AACA,4BAA4B,EAAE,GAAG,eAAe;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,qBAAqB;AACrB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AA+DE;;;AC/nB+G;AACnF;AACe;;AAE7C,MAAM,YAAI;AACV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED,MAAM,wBAAgB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,MAAC;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,GAAG;AACtD;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,eAAU;AAChD;;AAEA;AACA,mBAAmB,YAAI;AACvB;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4CAA4C,UAAU,kEAAkE;AACzI;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,sBAAsB,GAAG;AACzB;;;AAGA;AACA;AACA;;AAEA;AACA,oBAAoB,+DAA+D;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,sDAAsD;AAC5E;AACA;;AAEA;AACA,6BAA6B,YAAI;AACjC,kBAAkB,iBAAY,CAAC,MAAC,+BAA+B,MAAC;AAChE,oCAAoC,YAAI;AACxC;AACA;AACA,WAAW,MAAC,iBAAiB,MAAC;AAC9B;;AAEA;AACA,6BAA6B,YAAI;AACjC,kBAAkB,MAAC;AACnB;AACA,uBAAuB,MAAC;AACxB,cAAc,eAAe,YAAI,aAAa;AAC9C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,yCAAyC,MAAC;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD,UAAU;AACnE;;;AAGA;AACA;AACA;;AAEA;AACA,QAAQ,aAAa;AACrB,QAAQ,IAAI;AACZ;AACA,SAAS;AACT,KAAK;AACL,QAAQ,IAAI;AACZ;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2EAA2E,YAAI;AAC/E;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,eAAe,EAAE;AACvC;AACA;AACA,YAAY,aAAa;AACzB,gBAAgB,GAAG;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,YAAI;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,YAAI;AACrB;AACA;AACA;AACA;AACA,gBAAgB,YAAI;AACpB,4CAA4C,MAAC,6BAA6B,OAAO,QAAQ;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAI,cAAc,YAAI;AACvD,KAAK,4BAA4B,YAAI;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,GAAG;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,YAAY,MAAC;AACb;AACA;AACA;AACA;;;AAiDE;;;ACjnBkG;AAC3B;;AAEzE;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI,IAAI;AACR;AACA,KAAK;AACL;AACA;;AAEA;AACA,uDAAuD,GAAG;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,QAAQ;AAChB,eAAe,MAAM;AACrB;AACA,2BAA2B,IAAI;AAC/B;AACA,mBAAmB,aAAa;AAChC;AACA,IAAI,QAAQ;AACZ;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,IAAI,WAAW,CAAC,kBAAkB;AAClC,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA,KAAK;AACL,IAAI,QAAQ;AACZ;AACA,IAAI,QAAQ;AACZ;AACA;AACA,KAAK;AACL,IAAI,QAAQ;;AAEZ;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA,oBAAoB,IAAI;AACxB,6CAA6C,SAAS;AACtD;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,YAAY,IAAI;AAChB;AACA;AACA,KAAK;AACL;AACA,IAAI,QAAQ;AACZ;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAiBE;;;ACzJ4K;AAC1G;AACzC;;AAE3B,MAAM,WAAI;AACV;AACA;AACA;AACA,UAAU,kBAAkB;;AAErB;AACA;;;AAGP;AACA;AACA;;AAEA,WAAW,8BAA8B;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,IAAI;AACR,YAAY,UAAU;AACtB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,uBAAmB;AACxE;AACA;AACA,QAAQ,gBAAgB,YAAY,WAAI;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAS;AACzB;AACA,wHAAwH,SAAS,uDAAuD,SAAS;AACjM;;AAEA;AACA;AACA,eAAe,MAAM;AACrB;AACA,2BAA2B,6BAA6B;AACxD,WAAW,MAAM;AACjB;;AAEA;AACA,gBAAgB,EAAE;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,EAAE;AACX;AACA;AACA,kBAAkB,WAAI;AACtB;AACA;AACA,8BAA8B,aAAa,WAAW,EAAE;AACxD;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,MAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA,aAAa;AACb;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA,eAAe,MAAM,YAAY,cAAc,GAAG,SAAS;AAC3D;AACA,gCAAgC,MAAM;AACtC;AACA,aAAa;AACb,SAAS;AACT;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA,QAAQ,aAAa;AACrB,QAAQ,MAAM;AACd,KAAK;AACL;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAI;AAClC;AACA;AACA;AACA,uBAAuB,gBAAgB,CAAC,WAAI;AAC5C;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,qCAAqC,EAAE;AACvC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA,qBAAqB,EAAE;AACvB,wBAAwB,EAAE;AAC1B;AACA,mFAAmF,EAAE;AACrF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,IAAI;AACpB;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ,YAAY,IAAI;AAChB,qBAAqB,aAAa;AAClC;AACA;AACA,aAAa;AACb,SAAS;AACT,QAAQ,IAAI;AACZ,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC,oBAAoB,MAAM;AAC1B,iBAAiB;AACjB,oBAAoB,IAAI;AACxB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,mBAAmB,MAAM,GAAG;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAWE;;;AClcgD;AACkE;AACtE;AACH;;AAE3C,2BAA2B,YAAO;AAClC,0BAA0B,YAAO;AACjC,MAAM,QAAC,GAAG,kBAAkB;;AAE5B;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,SAAS;AACT;AACA;;AAEA;AACA;AACA,oDAAoD,OAAO;AAC3D;;AAEA;AACA,aAAa,GAAG,WAAW,cAAc;AACzC;AACA,KAAK;AACL;;AAEA;AACA;AACA,uCAAuC,OAAO;AAC9C;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,QAAC,QAAQ,eAAe,QAAG,IAAI;AACnC;;AAEA,eAAe;AACf;AACA,eAAe,QAAC;AAChB,KAAK;AACL;AACA;AACA,oBAAoB,QAAC;AACrB;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,aAAa,EAAE,OAAO;AACtB;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA,oBAAoB,QAAC;AACrB;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA,4DAA4D,OAAO,eAAe,MAAM;AACxF;AACA;AACA,+BAA+B,YAAO;AACtC;AACA;AACA,aAAa;AACb,6BAA6B,MAAM;AACnC,sDAAsD,uCAAuC;AAC7F;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC,SAAS;AACT;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAOE;;;AC9ImD;AACK;AACoD;AAC+D;AAC9B;AAC3E;;AAEpE,8BAA8B,4uCAA4uC;AAC1wC;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,QAAI;AACV,MAAM,aAAS;AACf;AACA,yBAAyB,YAAO;AAChC,0BAA0B,GAAG;AAC7B,0BAA0B,QAAG;AAC7B,qBAAqB,YAAO,CAAC,MAAC;;AAE9B;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,EAAE;AACpC;;AAEA;AACA,eAAe,aAAa,QAAI,mEAAmE,SAAS,gCAAgC;AAC5I;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,OAAO,6BAA6B,QAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;;AAE1B;AACA;AACA,uCAAuC,QAAQ;AAC/C,mBAAmB,QAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,8FAA8F,gBAAgB;AAC9G;;AAEA;AACA,kBAAkB,GAAG,CAAC,cAAc;AACpC;AACA,KAAK;AACL,WAAW,GAAG;AACd,eAAe,gBAAgB;AAC/B,KAAK;AACL;;AAEA;AACA,WAAW,MAAM;AACjB,eAAe,MAAC;AAChB,KAAK;AACL;;AAEA;AACA,IAAI,IAAI;AACR,YAAY,YAAY;AACxB,YAAY,YAAY;AACxB;AACA,aAAa;AACb;AACA,KAAK;AACL;;AAEA;AACA,yBAAyB,EAAE;AAC3B,kBAAkB,MAAC;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,gBAAgB,CAAC,QAAI;AAC7B,oBAAoB,cAAc;AAClC;AACA,SAAS;AACT,qBAAqB,GAAG;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB;AACA,aAAa;AACb,oEAAoE,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,QAAI;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,EAAE,kBAAkB,QAAI;AAC9C;AACA;AACA;AACA,mEAAmE,QAAI;AACvE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,yBAAyB,GAAG;AAC5B;AACA,2BAA2B,GAAG;AAC9B,mBAAmB,iBAAiB;AACpC,SAAS;AACT,yBAAyB,GAAG;AAC5B,mBAAmB,iBAAiB;AACpC,SAAS;AACT;AACA,mBAAmB,gBAAgB;AACnC,SAAS;AACT;AACA,oBAAoB,gBAAgB;AACpC,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,MAAC,8BAA8B;AAC/C,qBAAqB,OAAO,gBAAgB,OAAO;AACnD,IAAI,UAAU;;AAEd;AACA;AACA,qBAAqB,OAAO,OAAO,OAAO;AAC1C;;AAEA;AACA,gDAAgD,QAAI;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,aAAS;AAC/B;AACA,wBAAwB,aAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,GAAG,CAAC,SAAS;AAC5B,4BAA4B,YAAY;AACxC;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,6BAA6B;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,IAAI;AACZ,YAAY,IAAI;AAChB,yCAAyC,gBAAgB,CAAC,QAAI;AAC9D,oCAAoC,YAAY;AAChD;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B,oCAAoC,SAAS;AAC7C;AACA,mCAAmC,GAAG;AACtC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA,QAAQ,OAAO;AACf;AACA,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA,SAAS;AACT;;AAEA,IAAI,IAAI;AACR;AACA;AACA;AACA,SAAS;AACT,QAAQ,kBAAkB;AAC1B;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,YAAY;AAC5B;AACA;AACA,QAAQ,kBAAkB;AAC1B,KAAK;;AAEL,IAAI,IAAI,CAAC,QAAI;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,QAAQ,OAAO,SAAS,WAAW;AACrF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,MAAM,GAAG;AACzC;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA,4FAA4F,MAAM;AAClG;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0CAA0C,eAAe;AACzD,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C,0BAA0B,GAAG,mDAAmD,SAAS;AACzF;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA,KAAK;;AAEL,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB,QAAI,CAAC;AACzD;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,0CAA0C,QAAI;AAC9C;AACA;AACA,KAAK;AACL;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA,8CAAe;AACf;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,eAAe,cAAc;AAC7B,KAAK;AACL,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,kBAAkB;AAClB,QAAQ,cAAc;AACtB;AACA,eAAe,YAAY;AAC3B,KAAK;;AAEL,QAAQ;AACR,UAAU;AACV,cAAc;AACd,cAAc;;AAEd;AACA;AACA,CAAC,EAAC;;;ACtqB8B;AACE;AACC;AACM;AACD;AACb;;AAE3B,MAAM,UAAM,GAAG,MAAU;AACzB,MAAM,WAAO,GAAG,OAAW;AAC3B,MAAM,SAAK,GAAG,KAAS;AACvB,MAAM,UAAM,GAAG,MAAU;AACzB,MAAM,YAAQ,GAAG,QAAY;AAC7B,cAAc,IAAI,oBAAK,KAAK,uBAAQ;;AAEpC,0CAAe;AACf,UAAU;AACV,WAAW;AACX,SAAS;AACT,UAAU;AACV,YAAY;AACZ,QAAQ;AACR;AACA,OAAO;AACP,SAAS,uBAAO;AAChB,CAAC,EAAC;;AAYA;;;;;;;;ACpCF,kD;;;;;;;ACAA,iD;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"zeta.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"), require(\"promise-polyfill\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"zeta\", [\"jquery\", \"promise-polyfill\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"zeta\"] = factory(require(\"jquery\"), require(\"promise-polyfill\"));\n\telse\n\t\troot[\"zeta\"] = factory(root[\"$\"], root[\"promise-polyfill\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__44__, __WEBPACK_EXTERNAL_MODULE__804__) {\nreturn ","// @ts-nocheck\r\nconst root = document.documentElement;\r\n\r\nexport const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\r\nexport const IS_IE10 = !!window.ActiveXObject;\r\nexport const IS_IE = !!window.ActiveXObject || root.style.msTouchAction !== undefined || root.style.msUserSelect !== undefined;\r\nexport const IS_MAC = navigator.userAgent.indexOf('Macintosh') >= 0;\r\nexport const IS_TOUCH = 'ontouchstart' in window;\r\n","// @ts-nocheck\r\n\r\nconst Map = window.Map || (function () {\r\n    function indexOf(map, key) {\r\n        return map.items.indexOf(key);\r\n    }\r\n    function Map() {\r\n        var self = this;\r\n        self.items = [];\r\n        self._values = [];\r\n        self._keys = Set.prototype._keys;\r\n    }\r\n    Map.prototype = {\r\n        get size() {\r\n            return this.items.length;\r\n        },\r\n        has: function (v) {\r\n            return indexOf(this, v) >= 0;\r\n        },\r\n        get: function (v) {\r\n            var index = indexOf(this, v);\r\n            return index >= 0 ? this._values[index] : undefined;\r\n        },\r\n        set: function (i, v) {\r\n            var self = this;\r\n            var index = indexOf(self, i);\r\n            self._values[index >= 0 ? index : self.items.push(i) - 1] = v;\r\n            return self;\r\n        },\r\n        delete: function (v) {\r\n            var self = this;\r\n            var index = indexOf(self, v);\r\n            if (index >= 0) {\r\n                self.items.splice(index, 1);\r\n                self._values.splice(index, 1);\r\n            }\r\n            return index >= 0;\r\n        },\r\n        keys: function () {\r\n            return this._keys();\r\n        },\r\n        values: function () {\r\n            var self = this;\r\n            return self._keys(function (v) {\r\n                return self.get(v);\r\n            });\r\n        },\r\n        entries: function () {\r\n            var self = this;\r\n            return self._keys(function (v) {\r\n                return [v, self.get(v)];\r\n            });\r\n        },\r\n        forEach: function (callback, thisArg) {\r\n            var self = this;\r\n            self.items.forEach(function (v, i) {\r\n                callback.call(thisArg, self._values[i], v, self);\r\n            });\r\n        },\r\n        clear: function () {\r\n            this.items.splice(0);\r\n            this._values.splice(0);\r\n        }\r\n    };\r\n    return Map;\r\n}());\r\n\r\nconst Set = window.Set || (function () {\r\n    function Iterator(arr, callback) {\r\n        var self = this;\r\n        self.items = arr;\r\n        self.index = -1;\r\n        self.callback = callback || function (v) {\r\n            return v;\r\n        };\r\n    }\r\n    Iterator.prototype = {\r\n        next: function () {\r\n            var self = this;\r\n            if (++self.index < self.items.length) {\r\n                return {\r\n                    value: self.callback(self.items[self.index], self.index),\r\n                    done: false\r\n                };\r\n            }\r\n            return {\r\n                value: undefined,\r\n                done: true\r\n            };\r\n        }\r\n    };\r\n\r\n    function Set() {\r\n        this.items = [];\r\n    }\r\n    Set.prototype = {\r\n        get size() {\r\n            return this.items.length;\r\n        },\r\n        has: function (v) {\r\n            return this.items.indexOf(v) >= 0;\r\n        },\r\n        add: function (v) {\r\n            var items = this.items;\r\n            if (items.indexOf(v) < 0) {\r\n                items.push(v);\r\n            }\r\n            return this;\r\n        },\r\n        delete: function (v) {\r\n            var index = this.items.indexOf(v);\r\n            if (index >= 0) {\r\n                this.items.splice(index, 1);\r\n            }\r\n            return index >= 0;\r\n        },\r\n        keys: function () {\r\n            return this._keys();\r\n        },\r\n        values: function () {\r\n            return this._keys();\r\n        },\r\n        entries: function () {\r\n            return this._keys(function (v) {\r\n                return [v, v];\r\n            });\r\n        },\r\n        forEach: function (callback, thisArg) {\r\n            var self = this;\r\n            self.items.forEach(function (v) {\r\n                callback.call(thisArg, v, v, self);\r\n            });\r\n        },\r\n        clear: function () {\r\n            this.items.splice(0);\r\n        },\r\n        _keys: function (callback) {\r\n            return new Iterator(this.items, callback);\r\n        }\r\n    };\r\n    return Set;\r\n}());\r\n\r\nconst WeakMap = window.WeakMap || (function () {\r\n    var num = 0;\r\n    var state = 0;\r\n    var returnValue;\r\n\r\n    function WeakMap() {\r\n        this.key = '__WeakMap' + (++num);\r\n    }\r\n    WeakMap.prototype = {\r\n        get: function (key) {\r\n            if (this.has(key)) {\r\n                try {\r\n                    state = 1;\r\n                    key[this.key]();\r\n                    if (state !== 2) {\r\n                        throw new Error('Invalid operation');\r\n                    }\r\n                    var value = returnValue;\r\n                    returnValue = null;\r\n                    return value;\r\n                } finally {\r\n                    state = 0;\r\n                }\r\n            }\r\n        },\r\n        set: function (key, value) {\r\n            Object.defineProperty(key, this.key, {\r\n                configurable: true,\r\n                value: function () {\r\n                    if (state === 1) {\r\n                        returnValue = value;\r\n                        state = 2;\r\n                    }\r\n                }\r\n            });\r\n            return this;\r\n        },\r\n        has: function (key) {\r\n            return key && Object.hasOwnProperty.call(key, this.key);\r\n        },\r\n        delete: function (key) {\r\n            var has = this.has(key);\r\n            if (has) {\r\n                delete key[this.key];\r\n            }\r\n            return has;\r\n        }\r\n    };\r\n    return WeakMap;\r\n}());\r\n\r\nconst useRequire = typeof require === 'function';\r\nconst jQuery = window.jQuery || (useRequire && require('jquery'));\r\nconst Promise = window.Promise || (useRequire && require('promise-polyfill').default);\r\n\r\nexport {\r\n    jQuery as $,\r\n    Promise,\r\n    Map,\r\n    Set,\r\n    WeakMap\r\n};\r\n","import { Set, WeakMap, Promise } from \"./shim.js\";\r\n\r\nconst keys = Object.keys;\r\nconst freeze = Object.freeze;\r\nconst defineProperty = Object.defineProperty;\r\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\r\nconst getOwnPropertyNames = Object.getOwnPropertyNames;\r\nconst hasOwnPropertyImpl = Object.prototype.hasOwnProperty;\r\nconst propertyIsEnumerableImpl = Object.prototype.propertyIsEnumerable;\r\nconst values = Object.values || function (obj) {\r\n    var vals = [];\r\n    for (var key in obj) {\r\n        if (hasOwnPropertyImpl.call(obj, key) && propertyIsEnumerableImpl.call(obj, key)) {\r\n            vals.push(obj[key]);\r\n        }\r\n    }\r\n    return vals;\r\n};\r\n\r\nvar matchWordCache;\r\nvar watchStore;\r\n\r\n/* --------------------------------------\r\n * Miscellaneous\r\n * -------------------------------------- */\r\n\r\nfunction noop() { }\r\n\r\nfunction either(x, y) {\r\n    return x ^ y;\r\n}\r\n\r\nfunction isArray(obj) {\r\n    return Array.isArray(obj) && obj;\r\n}\r\n\r\nfunction isFunction(obj) {\r\n    return typeof obj === 'function' && obj;\r\n}\r\n\r\nfunction isPlainObject(obj) {\r\n    var proto = typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj);\r\n    return (proto === Object.prototype || proto === null) && obj;\r\n}\r\n\r\nfunction isArrayLike(obj) {\r\n    if (isFunction(obj) || obj === window) {\r\n        return false;\r\n    }\r\n    var length = !!obj && 'length' in obj && obj.length;\r\n    return isArray(obj) || length === 0 || (typeof length === 'number' && length > 0 && (length - 1) in obj);\r\n}\r\n\r\nfunction makeArray(obj) {\r\n    if (isArray(obj)) {\r\n        return obj.slice(0);\r\n    }\r\n    if (typeof obj === 'string') {\r\n        return [obj];\r\n    }\r\n    if (obj && (isArrayLike(obj) || isFunction(obj.forEach))) {\r\n        var arr = [];\r\n        each(obj, function (i, v) {\r\n            arr[arr.length] = v;\r\n        });\r\n        return arr;\r\n    }\r\n    return obj !== null && obj !== undefined ? [obj] : [];\r\n}\r\n\r\nfunction extend() {\r\n    var options, name, src, copy, copyIsArray, clone;\r\n    var target = arguments[0] || {};\r\n    var i = 1;\r\n    var length = arguments.length;\r\n    var deep = false;\r\n\r\n    if (typeof target === 'boolean') {\r\n        deep = target;\r\n        target = arguments[i] || {};\r\n        i++;\r\n    }\r\n    if (typeof target !== 'object' && !isFunction(target)) {\r\n        target = {};\r\n    }\r\n    for (; i < length; i++) {\r\n        if ((options = arguments[i]) !== null) {\r\n            for (name in options) {\r\n                src = target[name];\r\n                copy = options[name];\r\n\r\n                // prevent never-ending loop\r\n                if (target === copy) {\r\n                    continue;\r\n                }\r\n                // recurse if we're merging plain objects or arrays\r\n                if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\r\n                    if (copyIsArray) {\r\n                        copyIsArray = false;\r\n                        clone = src && isArray(src) ? src : [];\r\n                    } else {\r\n                        clone = src && isPlainObject(src) ? src : {};\r\n                    }\r\n                    // never move original objects, clone them\r\n                    target[name] = extend(deep, clone, copy);\r\n                } else if (copy !== undefined) {\r\n                    // don't bring in undefined values\r\n                    target[name] = copy;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}\r\n\r\nfunction each(obj, callback) {\r\n    if (obj) {\r\n        var cur, i = 0;\r\n        if (typeof obj === 'string') {\r\n            obj = obj.split(' ');\r\n        } else if (obj instanceof Set) {\r\n            // would be less useful if key and value refers to the same object\r\n            obj = isFunction(obj.values) ? obj.values() : (function (obj, arr) {\r\n                return obj.forEach(function (v) {\r\n                    // @ts-ignore: arr is hinted as never[]\r\n                    arr[arr.length] = v;\r\n                }), arr;\r\n            }(obj, []));\r\n        }\r\n        if (isArrayLike(obj)) {\r\n            var len = obj.length;\r\n            while (i < len && callback(i, obj[i++]) !== false);\r\n        } else if (isFunction(obj.entries)) {\r\n            obj = obj.entries();\r\n            while (!(cur = obj.next()).done && callback(cur.value[0], cur.value[1]) !== false);\r\n        } else if (isFunction(obj.forEach)) {\r\n            var value;\r\n            obj.forEach(function (v, i) {\r\n                value = value === false || callback(i, v);\r\n            });\r\n        } else if (isFunction(obj.next)) {\r\n            while (!(cur = obj.next()).done && callback(i++, cur.value) !== false);\r\n        } else if (isFunction(obj.nextNode)) {\r\n            while ((cur = obj.nextNode()) && callback(i++, cur) !== false);\r\n        } else {\r\n            // @ts-ignore: i is unused elsewhere thus can be assigned string\r\n            for (i in obj) {\r\n                if (callback(i, obj[i]) === false) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction map(obj, callback) {\r\n    var arr = [];\r\n    each(obj, function (i, v) {\r\n        var result = callback.call(this, v, i);\r\n        if (result !== null && result !== undefined) {\r\n            if (isArray(result)) {\r\n                arr.push.apply(arr, result);\r\n            } else {\r\n                arr[arr.length] = result;\r\n            }\r\n        }\r\n    });\r\n    return arr;\r\n}\r\n\r\nfunction any(obj, callback) {\r\n    var result;\r\n    each(obj, function (i, v) {\r\n        result = callback.call(this, v, i) && v;\r\n        return !result;\r\n    });\r\n    return result;\r\n}\r\n\r\nfunction single(obj, callback) {\r\n    var result;\r\n    each(obj, function (i, v) {\r\n        result = callback.call(this, v, i);\r\n        return !result;\r\n    });\r\n    return result;\r\n}\r\n\r\nfunction kv(key, value) {\r\n    var obj = {};\r\n    obj[key] = value;\r\n    return obj;\r\n}\r\n\r\nfunction mapGet(map, key, fn) {\r\n    return map.get(key) || fn && (map.set(key, new fn()), map.get(key));\r\n}\r\n\r\nfunction mapRemove(map, key) {\r\n    var value = map.get(key);\r\n    map.delete(key);\r\n    return value;\r\n}\r\n\r\nfunction createPrivateStore() {\r\n    var map = new WeakMap();\r\n    return function (obj, value) {\r\n        if (value) {\r\n            map.set(obj, value);\r\n        }\r\n        return value || map.get(obj);\r\n    };\r\n}\r\n\r\nfunction setImmediate(fn) {\r\n    var args = [].slice.call(arguments, 1);\r\n    resolve().then(function () {\r\n        fn.apply(undefined, args);\r\n    });\r\n}\r\n\r\nfunction setTimeoutOnce(fn) {\r\n    fn.timeout = fn.timeout || setTimeout(function () {\r\n        fn.timeout = null;\r\n        fn();\r\n    });\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Throw helper\r\n * -------------------------------------- */\r\n\r\nfunction throwNotFunction(obj, name) {\r\n    if (!isFunction(obj)) {\r\n        throw new Error((name || 'callback') + ' must be a function');\r\n    }\r\n    return obj;\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Strings\r\n * -------------------------------------- */\r\n\r\nfunction iequal(a, b) {\r\n    return a.toLowerCase() === b.toLowerCase();\r\n}\r\n\r\nfunction randomId() {\r\n    return Math.random().toString(36).substr(2, 8);\r\n}\r\n\r\nfunction repeat(str, count) {\r\n    return new Array(count + 1).join(str);\r\n}\r\n\r\nfunction camel(str) {\r\n    return String(str).replace(/-([a-z])/g, function (v, a) {\r\n        return a.toUpperCase();\r\n    });\r\n}\r\n\r\nfunction hyphenate(str) {\r\n    return String(str).replace(/[A-Z](?![A-Z])|[A-Z]{2,}(?=[A-Z])/g, function (v, a) {\r\n        return (a ? '-' : '') + v.toLowerCase();\r\n    });\r\n}\r\n\r\nfunction ucfirst(v) {\r\n    v = String(v || '');\r\n    return v.charAt(0).toUpperCase() + v.slice(1);\r\n}\r\n\r\nfunction lcfirst(v) {\r\n    v = String(v || '');\r\n    return v.charAt(0).toLowerCase() + v.slice(1);\r\n}\r\n\r\nfunction trim(v) {\r\n    return String(v || '').replace(/^(?:\\u200b|[^\\S\\u00a0])+|(?:\\u200b|[^\\S\\u00a0])+$/g, '');\r\n}\r\n\r\nfunction matchWord(haystack, needle) {\r\n    var cache = matchWordCache || (matchWordCache = {});\r\n    var re = cache[needle] || (cache[needle] = new RegExp('(?:^|\\\\s)(' + needle.replace(/\\s+/g, '|') + ')(?=$|\\\\s)'));\r\n    return re.test(String(haystack || '')) && RegExp.$1;\r\n}\r\n\r\nfunction htmlDecode(input) {\r\n    return input && new DOMParser().parseFromString(input, 'text/html').documentElement.textContent;\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Promise related\r\n * -------------------------------------- */\r\n\r\nfunction resolve(value) {\r\n    return Promise.resolve(value);\r\n}\r\n\r\nfunction reject(reason) {\r\n    return Promise.reject(reason);\r\n}\r\n\r\nfunction always(promise, callback) {\r\n    return promise.then(function (v) {\r\n        return callback(true, v);\r\n    }, function (v) {\r\n        return callback(false, v);\r\n    });\r\n}\r\n\r\nfunction resolveAll(obj, callback) {\r\n    if (!obj || typeof obj !== 'object') {\r\n        return Promise.resolve(obj).then(callback);\r\n    }\r\n    if (obj instanceof Promise || isFunction(obj.then)) {\r\n        return obj.then(callback);\r\n    }\r\n    if (isArray(obj)) {\r\n        return Promise.all(obj).then(function (d) {\r\n            return isFunction(callback) ? callback(d) : d;\r\n        });\r\n    }\r\n    var result = {};\r\n    return Promise.all(keys(obj).map(function (v) {\r\n        return resolveAll(obj[v], function (d) {\r\n            result[v] = d;\r\n        });\r\n    })).then(function () {\r\n        return isFunction(callback) ? callback(result) : result;\r\n    });\r\n}\r\n\r\nfunction catchAsync(promise) {\r\n    return promise.catch(noop);\r\n}\r\n\r\nfunction setPromiseTimeout(promise, ms, resolveWhenTimeout) {\r\n    return new Promise(function (resolve, reject) {\r\n        promise.then(resolve, reject);\r\n        setTimeout(function () {\r\n            (resolveWhenTimeout ? resolve : reject)('timeout');\r\n        }, ms);\r\n    });\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Property and prototype\r\n * -------------------------------------- */\r\n\r\nfunction hasOwnProperty(obj, prop) {\r\n    return hasOwnPropertyImpl.call(obj, prop);\r\n}\r\n\r\nfunction getOwnPropertyDescriptors(obj) {\r\n    var props = {};\r\n    each(getOwnPropertyNames(obj || {}), function (i, v) {\r\n        props[v] = getOwnPropertyDescriptor(obj, v);\r\n    });\r\n    return props;\r\n}\r\n\r\nfunction define(o, p) {\r\n    o = extend(function () { }, { prototype: o });\r\n    definePrototype(o, p);\r\n}\r\n\r\nfunction defineOwnProperty(obj, name, value, readonly) {\r\n    Object.defineProperty(obj, name, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        writable: !readonly,\r\n        value: value\r\n    });\r\n}\r\n\r\nfunction defineGetterProperty(obj, name, get, set) {\r\n    defineProperty(obj, name, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: get,\r\n        set: set\r\n    });\r\n}\r\n\r\nfunction defineHiddenProperty(obj, name, value, readonly) {\r\n    defineProperty(obj, name, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        writable: !readonly,\r\n        value: value\r\n    });\r\n}\r\n\r\nfunction definePrototype(fn, prototype) {\r\n    each(getOwnPropertyDescriptors(prototype), function (i, v) {\r\n        v.enumerable = !isFunction(v.value);\r\n        defineProperty(fn.prototype, i, v);\r\n    });\r\n}\r\n\r\nfunction inherit(proto, props) {\r\n    var obj = Object.create(isFunction(proto) ? proto.prototype : proto || Object.prototype);\r\n    each(getOwnPropertyDescriptors(props), function (i, v) {\r\n        defineProperty(obj, i, v);\r\n    });\r\n    return obj;\r\n}\r\n\r\nfunction deepFreeze(obj) {\r\n    freeze(obj);\r\n    getOwnPropertyNames(obj).forEach(function (v) {\r\n        var value = obj[v];\r\n        if (value && typeof value === 'object') {\r\n            deepFreeze(value);\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Observable\r\n * -------------------------------------- */\r\n\r\nfunction getObservableState(obj, sync) {\r\n    var cache = watchStore || (watchStore = createPrivateStore());\r\n    return cache(obj) || cache(obj, {\r\n        sync: !!sync,\r\n        values: {},\r\n        oldValues: {},\r\n        newValues: {},\r\n        alias: {},\r\n        handlers: [],\r\n        handleChanges: function (callback) {\r\n            var self = cache(obj);\r\n            try {\r\n                self.lock = true;\r\n                do {\r\n                    var oldValues = self.oldValues;\r\n                    var newValues = self.newValues;\r\n                    if (isFunction(callback)) {\r\n                        callback();\r\n                    }\r\n                    if (getOwnPropertyNames(oldValues)[0]) {\r\n                        for (var i in oldValues) {\r\n                            if (oldValues[i] === newValues[i]) {\r\n                                delete oldValues[i];\r\n                                delete newValues[i];\r\n                            }\r\n                        }\r\n                        self.oldValues = {};\r\n                        self.newValues = {};\r\n                        self.handlers.slice(0).forEach(function (v) {\r\n                            v.call(obj, {\r\n                                oldValues: oldValues,\r\n                                newValues: newValues\r\n                            });\r\n                        });\r\n                    }\r\n                } while (self.sync && getOwnPropertyNames(self.oldValues)[0]);\r\n            } finally {\r\n                self.lock = false;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction defineAliasProperty(obj, prop, target, targetProp) {\r\n    var desc = getOwnPropertyDescriptor(obj, prop);\r\n    if (!desc ? prop in obj : desc.get || desc.set) {\r\n        throw new Error('Cannot create alias property');\r\n    }\r\n    targetProp = targetProp || prop;\r\n    defineGetterProperty(obj, prop, function () {\r\n        return target[targetProp];\r\n    }, function (value) {\r\n        target[targetProp] = value;\r\n    });\r\n    var state = getObservableState(obj);\r\n    state.alias[prop] = getObservableState(target).alias[targetProp] || [target, targetProp];\r\n}\r\n\r\nfunction defineObservableProperty(obj, prop, initialValue) {\r\n    var state = getObservableState(obj);\r\n    var alias = state.alias[prop];\r\n    if (alias) {\r\n        return defineObservableProperty(alias[0], alias[1], initialValue);\r\n    }\r\n    if (!(prop in state.values)) {\r\n        var desc = getOwnPropertyDescriptor(obj, prop);\r\n        if (!desc ? prop in obj : desc.get || desc.set) {\r\n            throw new Error('Only own data property can be observed');\r\n        }\r\n        var setter = function (value) {\r\n            var state = getObservableState(this);\r\n            if (value !== state.values[prop]) {\r\n                if (!(prop in state.oldValues)) {\r\n                    state.oldValues[prop] = state.values[prop];\r\n                }\r\n                state.values[prop] = value;\r\n                state.newValues[prop] = value;\r\n                if (!state.sync) {\r\n                    setTimeoutOnce(state.handleChanges);\r\n                } else if (!state.lock) {\r\n                    state.handleChanges();\r\n                }\r\n            }\r\n        };\r\n        state.values[prop] = prop in obj ? obj[prop] : initialValue;\r\n        defineGetterProperty(obj, prop, function () {\r\n            var state = getObservableState(this);\r\n            return state.values[prop];\r\n        }, initialValue !== undefined ? undefined : setter);\r\n        return setter.bind(obj);\r\n    }\r\n}\r\n\r\nfunction watch(obj, prop, handler, fireInit) {\r\n    if (prop === true) {\r\n        var state = getObservableState(obj, true);\r\n        return state.handleChanges;\r\n    }\r\n    if (isFunction(prop)) {\r\n        getObservableState(obj).handlers.push(prop);\r\n    } else {\r\n        defineObservableProperty(obj, prop);\r\n        if (isFunction(handler)) {\r\n            var alias = getObservableState(obj).alias[prop] || [obj, prop];\r\n            var handlers = getObservableState(alias[0]).handlers;\r\n            handlers.push(function (e) {\r\n                if (alias[1] in e.newValues) {\r\n                    handler.call(obj, e.newValues[alias[1]], e.oldValues[alias[1]], prop, obj);\r\n                }\r\n            });\r\n            if (fireInit) {\r\n                handler.call(obj, obj[prop], null, prop, obj);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction watchOnce(obj, prop, handler) {\r\n    defineObservableProperty(obj, prop);\r\n    return new Promise(function (resolve) {\r\n        var alias = getObservableState(obj).alias[prop] || [obj, prop];\r\n        var handlers = getObservableState(alias[0]).handlers;\r\n        handlers.push(function fn(e) {\r\n            if (alias[1] in e.newValues) {\r\n                var value = e.newValues[alias[1]];\r\n                var returnValue;\r\n                handlers.splice(handlers.indexOf(fn), 1);\r\n                if (isFunction(handler)) {\r\n                    returnValue = handler(value);\r\n                }\r\n                resolve(returnValue === undefined ? value : returnValue);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nfunction watchable(obj) {\r\n    obj = obj || {};\r\n    define(obj, {\r\n        watch: function (prop, handler, fireInit) {\r\n            watch(this, prop, handler, fireInit);\r\n        },\r\n        watchOnce: function (prop, handler) {\r\n            return watchOnce(this, prop, handler);\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n\r\nexport {\r\n    // miscellanous\r\n    noop,\r\n    either,\r\n    isArray,\r\n    isFunction,\r\n    isPlainObject,\r\n    isArrayLike,\r\n    makeArray,\r\n    extend,\r\n    each,\r\n    map,\r\n    any,\r\n    single,\r\n    kv,\r\n    mapGet,\r\n    mapRemove,\r\n    createPrivateStore,\r\n    setTimeoutOnce,\r\n    setImmediate,\r\n\r\n    // throw\r\n    throwNotFunction,\r\n\r\n    // property and prototype related\r\n    keys,\r\n    values,\r\n    hasOwnProperty,\r\n    getOwnPropertyDescriptors,\r\n    define,\r\n    definePrototype,\r\n    defineOwnProperty,\r\n    defineGetterProperty,\r\n    defineHiddenProperty,\r\n    defineAliasProperty,\r\n    defineObservableProperty,\r\n    watch,\r\n    watchOnce,\r\n    watchable,\r\n    inherit,\r\n    deepFreeze,\r\n\r\n    // string related\r\n    iequal,\r\n    randomId,\r\n    repeat,\r\n    camel,\r\n    hyphenate,\r\n    ucfirst,\r\n    lcfirst,\r\n    trim,\r\n    matchWord,\r\n    htmlDecode,\r\n\r\n    // promise\r\n    resolve,\r\n    reject,\r\n    always,\r\n    resolveAll,\r\n    catchAsync,\r\n    setPromiseTimeout\r\n};\r\n","import { any, isFunction, isPlainObject, each, map, definePrototype, kv, noop, setTimeoutOnce } from \"./util.js\";\r\nimport { $ } from \"./shim.js\";\r\nimport { throwNotFunction } from \"./util.js\";\r\n\r\nconst root = document.documentElement;\r\nconst selection = window.getSelection();\r\n// @ts-ignore: non-standard member\r\nconst elementsFromPoint = document.msElementsFromPoint || document.elementsFromPoint;\r\nconst compareDocumentPositionImpl = document.compareDocumentPosition;\r\nconst compareBoundaryPointsImpl = Range.prototype.compareBoundaryPoints;\r\n\r\nvar originDiv;\r\n\r\n/* --------------------------------------\r\n * Custom class\r\n * -------------------------------------- */\r\n\r\nfunction Rect(l, t, r, b) {\r\n    var self = this;\r\n    self.left = l;\r\n    self.top = t;\r\n    self.right = r;\r\n    self.bottom = b;\r\n}\r\n\r\ndefinePrototype(Rect, {\r\n    get width() {\r\n        return this.right - this.left;\r\n    },\r\n    get height() {\r\n        return this.bottom - this.top;\r\n    },\r\n    get centerX() {\r\n        return (this.left + this.right) / 2;\r\n    },\r\n    get centerY() {\r\n        return (this.top + this.bottom) / 2;\r\n    },\r\n    collapse: function (side, offset) {\r\n        var rect = this;\r\n        var pos = rect[side] + (offset || 0);\r\n        return side === 'left' || side === 'right' ? toPlainRect(pos, rect.top, pos, rect.bottom) : toPlainRect(rect.left, pos, rect.right, pos);\r\n    },\r\n    translate: function (x, y) {\r\n        var self = this;\r\n        return toPlainRect(self.left + x, self.top + y, self.right + x, self.bottom + y);\r\n    }\r\n});\r\n\r\nconst MutationObserver = window.MutationObserver || (function () {\r\n    function MutationObserver(handler) {\r\n        var self = this;\r\n        this.records = [];\r\n        this.handler = function () {\r\n            handler(self.takeRecords(), self);\r\n        };\r\n        throwNotFunction(handler);\r\n    }\r\n    MutationObserver.prototype = {\r\n        observe: function (element, init) {\r\n            var self = this;\r\n            bind(element, 'DOMNodeInserted DOMNodeRemoved DOMAttrModified DOMCharacterDataModified', function (e) {\r\n                var type = e.type.charAt(7);\r\n                var oldValue = e.prevValue;\r\n                var record = {};\r\n                record.addedNodes = [];\r\n                record.removedNodes = [];\r\n                if (type === 'M') {\r\n                    record.type = 'attributes';\r\n                    record.target = e.target;\r\n                    record.attributeName = e.attrName;\r\n                    if (init.attributeOldValue) {\r\n                        record.oldValue = oldValue;\r\n                    }\r\n                } else if (type === 'a') {\r\n                    record.type = 'characterData';\r\n                    record.target = e.target;\r\n                    if (init.characterDataOldValue) {\r\n                        record.oldValue = oldValue;\r\n                    }\r\n                } else {\r\n                    record.type = 'childList';\r\n                    record.target = e.target.parentNode;\r\n                    record[type === 'I' ? 'addedNodes' : 'removedNodes'][0] = e.target;\r\n                }\r\n                var shouldIgnore = any(self.records, function (v) {\r\n                    return v.type === 'childList' && v.addedNodes.some(function (v) {\r\n                        return containsOrEquals(v, record.target);\r\n                    });\r\n                });\r\n                if (!shouldIgnore && init[record.type] && (init.subtree || record.target === element)) {\r\n                    self.records[self.records.length] = record;\r\n                    setTimeoutOnce(self.handler);\r\n                }\r\n            });\r\n        },\r\n        takeRecords: function () {\r\n            return this.records.splice(0);\r\n        }\r\n    };\r\n    return MutationObserver;\r\n}());\r\n\r\n\r\n/* --------------------------------------\r\n * General helper\r\n * -------------------------------------- */\r\n\r\nfunction tagName(element) {\r\n    return element && element.tagName && element.tagName.toLowerCase();\r\n}\r\n\r\nfunction is(element, selector) {\r\n    if (!element || !selector) {\r\n        return false;\r\n    }\r\n    // constructors of native DOM objects in Safari refuse to be functions\r\n    // use a fairly accurate but fast checking instead of isFunction\r\n    if (selector.prototype) {\r\n        return element instanceof selector && element;\r\n    }\r\n    if (selector.toFixed) {\r\n        return (element.nodeType & selector) && element;\r\n    }\r\n    return (selector === '*' || tagName(element) === selector || $(element).is(selector)) && element;\r\n}\r\n\r\nfunction sameElementSpec(a, b) {\r\n    if (tagName(a) !== tagName(b)) {\r\n        return false;\r\n    }\r\n    var thisAttr = a.attributes;\r\n    var prevAttr = b.attributes;\r\n    return thisAttr.length === prevAttr.length && !any(thisAttr, function (v) {\r\n        return !prevAttr[v.nodeName] || v.value !== prevAttr[v.nodeName].value;\r\n    });\r\n}\r\n\r\nfunction comparePosition(a, b, strict) {\r\n    if (a === b) {\r\n        return 0;\r\n    }\r\n    var v = a && b && compareDocumentPositionImpl.call(a, b);\r\n    if (v & 2) {\r\n        return (strict && v & 8) || (v & 1) ? NaN : 1;\r\n    }\r\n    if (v & 4) {\r\n        return (strict && v & 16) || (v & 1) ? NaN : -1;\r\n    }\r\n    return NaN;\r\n}\r\n\r\nfunction connected(a, b) {\r\n    return a && b && !(compareDocumentPositionImpl.call(a.commonAncestorContainer || a, b.commonAncestorContainer || b) & 1);\r\n}\r\n\r\nfunction containsOrEquals(container, contained) {\r\n    container = (container || '').element || container;\r\n    contained = (contained || '').element || contained;\r\n    return container === contained || $.contains(container, contained);\r\n}\r\n\r\nfunction isVisible(element) {\r\n    if (!connected(root, element)) {\r\n        return false;\r\n    }\r\n    var rect = getRect(element);\r\n    if (!rect.top && !rect.left && !rect.width && !rect.height) {\r\n        for (var cur = element; cur; cur = cur.parentNode) {\r\n            if (getComputedStyle(cur).display === 'none') {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction acceptNode(iterator, node) {\r\n    node = node || iterator.currentNode;\r\n    if (!node || !(iterator.whatToShow & (is(node, Node) ? (1 << (node.nodeType - 1)) : node.nodeType))) {\r\n        return 3;\r\n    }\r\n    return !iterator.filter ? 1 : (iterator.filter.acceptNode || iterator.filter).call(iterator.filter, node);\r\n}\r\n\r\nfunction iterateNode(iterator, callback, from, until) {\r\n    var i = 0;\r\n    iterator.currentNode = from = from || iterator.currentNode;\r\n    callback = callback || noop;\r\n    switch (acceptNode(iterator)) {\r\n        case 2:\r\n            return;\r\n        case 1:\r\n            callback(from, i++);\r\n    }\r\n    for (var cur; (cur = iterator.nextNode()) && (!until || (isFunction(until) ? until(cur) : cur !== until || void callback(cur, i++))); callback(cur, i++));\r\n}\r\n\r\nfunction iterateNodeToArray(iterator, callback, from, until) {\r\n    var result = [];\r\n    iterateNode(iterator, function (v) {\r\n        result[result.length] = v;\r\n    }, from, until);\r\n    return callback ? map(result, callback) : result;\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Advanced traversal\r\n * -------------------------------------- */\r\n\r\nfunction getCommonAncestor(a, b) {\r\n    for (b = b || a; a && a !== b && compareDocumentPositionImpl.call(a, b) !== 20; a = a.parentNode);\r\n    return a;\r\n}\r\n\r\nfunction parentsAndSelf(element) {\r\n    if (element === window) {\r\n        return [];\r\n    }\r\n    for (var arr = []; element && element !== document && arr.push(element); element = element.parentNode || element.parent);\r\n    return arr;\r\n}\r\n\r\nfunction selectIncludeSelf(selector, container) {\r\n    container = container || root;\r\n    var matched = $.uniqueSort($(container).find(selector).add($(container).filter(selector)).get());\r\n    if (matched[0] || container === root) {\r\n        return matched;\r\n    }\r\n    return $(container).find($(selector)).get();\r\n}\r\n\r\nfunction selectClosestRelative(selector, container) {\r\n    container = container || root;\r\n    var element = $(selector, container)[0];\r\n    if (!element) {\r\n        var $matched = $(selector);\r\n        for (; container !== root && !element; container = container.parentNode) {\r\n            element = $matched.get().filter(function (v) {\r\n                return containsOrEquals(container, v);\r\n            })[0];\r\n        }\r\n    }\r\n    return element;\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Create\r\n * -------------------------------------- */\r\n\r\nfunction createDocumentFragment(node) {\r\n    return is(node, DocumentFragment) || $(document.createDocumentFragment()).append(node)[0];\r\n}\r\n\r\nfunction createTextNode(text) {\r\n    return document.createTextNode(text || '\\u200b');\r\n}\r\n\r\nfunction createElement(name) {\r\n    return document.createElement(name);\r\n}\r\n\r\nfunction createNodeIterator(root, whatToShow, filter) {\r\n    // @ts-ignore: assume filter is of correct signature\r\n    return document.createNodeIterator(root, whatToShow, isFunction(filter) || null, false);\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Events\r\n * -------------------------------------- */\r\n\r\nfunction addOrRemoveEventListener(method, element, event, listener, useCapture) {\r\n    if (isPlainObject(event)) {\r\n        each(event, function (i, v) {\r\n            element[method](i, v, listener);\r\n        });\r\n    } else if (typeof event === 'string') {\r\n        each(event.split(' '), function (i, v) {\r\n            element[method](v, listener, useCapture);\r\n        });\r\n    }\r\n}\r\n\r\nfunction bind(element, event, listener, useCapture) {\r\n    addOrRemoveEventListener('addEventListener', element, event, listener, useCapture);\r\n    return function () {\r\n        unbind(element, event, listener);\r\n    };\r\n}\r\n\r\nfunction unbind(element, event, listener) {\r\n    addOrRemoveEventListener('removeEventListener', element, event, listener);\r\n}\r\n\r\nfunction dispatchDOMMouseEvent(eventName, point, e) {\r\n    if (typeof eventName !== 'string') {\r\n        e = eventName;\r\n        eventName = e.type;\r\n    }\r\n    var target = point ? elementFromPoint(point.clientX, point.clientY) || root : e.target;\r\n    var event = document.createEvent('MouseEvent');\r\n    point = point || e;\r\n    event.initMouseEvent(eventName, e.bubbles, e.cancelable, e.view, e.detail, point.screenX, point.screenY, point.clientX, point.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\r\n    return target.dispatchEvent(event);\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * DOM manip\r\n * -------------------------------------- */\r\n\r\nfunction removeNode(node) {\r\n    if (node.parentNode) {\r\n        node.parentNode.removeChild(node);\r\n    }\r\n}\r\n\r\nfunction getClass(element, className) {\r\n    var re = new RegExp('(?:^|\\\\s+)' + className + '(?:-(\\\\S+)|\\\\b)', 'ig');\r\n    var t = [false];\r\n    (element.className || '').replace(re, function (v, a) {\r\n        t[a ? t.length : 0] = a || true;\r\n    });\r\n    return t[1] ? t.slice(1) : t[0];\r\n}\r\n\r\nfunction setClass(element, className, values) {\r\n    var value = element.className || '';\r\n    each(isPlainObject(className) || kv(className, values), function (i, v) {\r\n        var re = new RegExp('(^|\\\\s)\\\\s*' + i + '(?:-(\\\\S+)|\\\\b)|\\\\s*$', 'ig');\r\n        var replaced = 0;\r\n        if (isPlainObject(v)) {\r\n            v = map(v, function (v, i) {\r\n                return v ? i : null;\r\n            });\r\n        }\r\n        value = value.replace(re, function () {\r\n            return replaced++ || !v || v.length === 0 ? '' : (' ' + i + (v[0] ? [''].concat(v).join(' ' + i + '-') : ''));\r\n        });\r\n    });\r\n    element.className = value;\r\n}\r\n\r\nfunction getScrollOffset(winOrElm) {\r\n    return {\r\n        x: winOrElm.pageXOffset || winOrElm.scrollLeft || 0,\r\n        y: winOrElm.pageYOffset || winOrElm.scrollTop || 0\r\n    };\r\n}\r\n\r\nfunction scrollBy(element, x, y) {\r\n    var winOrElm = element === root || element === document.body ? window : element;\r\n    var orig = getScrollOffset(winOrElm);\r\n    if (winOrElm.scrollBy) {\r\n        winOrElm.scrollBy(x, y);\r\n    } else {\r\n        winOrElm.scrollLeft = orig.x + x;\r\n        winOrElm.scrollTop = orig.y + y;\r\n    }\r\n    var cur = getScrollOffset(winOrElm);\r\n    return {\r\n        x: cur.x - orig.x,\r\n        y: cur.y - orig.y\r\n    };\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Range and rect\r\n * -------------------------------------- */\r\n\r\nfunction createRange(startNode, startOffset, endNode, endOffset) {\r\n    if (startNode && isFunction(startNode.getRange)) {\r\n        return startNode.getRange();\r\n    }\r\n    var range;\r\n    if (is(startNode, Node)) {\r\n        range = document.createRange();\r\n        if (+startOffset !== startOffset) {\r\n            range[(startOffset === 'contents' || !startNode.parentNode) ? 'selectNodeContents' : 'selectNode'](startNode);\r\n            if (typeof startOffset === 'boolean') {\r\n                range.collapse(startOffset);\r\n            }\r\n        } else {\r\n            range.setStart(startNode, getOffset(startNode, startOffset));\r\n        }\r\n        if (is(endNode, Node) && connected(startNode, endNode)) {\r\n            range.setEnd(endNode, getOffset(endNode, endOffset));\r\n        }\r\n    } else if (is(startNode, Range)) {\r\n        range = startNode.cloneRange();\r\n        if (!range.collapsed && typeof startOffset === 'boolean') {\r\n            range.collapse(startOffset);\r\n        }\r\n    }\r\n    if (is(startOffset, Range) && connected(range, startOffset)) {\r\n        var inverse = range.collapsed && startOffset.collapsed ? -1 : 1;\r\n        if (compareBoundaryPointsImpl.call(range, 0, startOffset) * inverse < 0) {\r\n            range.setStart(startOffset.startContainer, startOffset.startOffset);\r\n        }\r\n        if (compareBoundaryPointsImpl.call(range, 2, startOffset) * inverse > 0) {\r\n            range.setEnd(startOffset.endContainer, startOffset.endOffset);\r\n        }\r\n    }\r\n    return range;\r\n}\r\n\r\nfunction rangeIntersects(a, b) {\r\n    a = is(a, Range) || createRange(a);\r\n    b = is(b, Range) || createRange(b);\r\n    return connected(a, b) && compareBoundaryPointsImpl.call(a, 3, b) <= 0 && compareBoundaryPointsImpl.call(a, 1, b) >= 0;\r\n}\r\n\r\nfunction rangeCovers(a, b) {\r\n    a = is(a, Range) || createRange(a);\r\n    b = is(b, Range) || createRange(b);\r\n    return connected(a, b) && compareBoundaryPointsImpl.call(a, 0, b) <= 0 && compareBoundaryPointsImpl.call(a, 2, b) >= 0;\r\n}\r\n\r\nfunction rangeEquals(a, b) {\r\n    a = is(a, Range) || createRange(a);\r\n    b = is(b, Range) || createRange(b);\r\n    return connected(a, b) && compareBoundaryPointsImpl.call(a, 0, b) === 0 && compareBoundaryPointsImpl.call(a, 2, b) === 0;\r\n}\r\n\r\nfunction compareRangePosition(a, b, strict) {\r\n    a = is(a, Range) || createRange(a);\r\n    b = is(b, Range) || createRange(b);\r\n    var value = !connected(a, b) ? NaN : compareBoundaryPointsImpl.call(a, 0, b) + compareBoundaryPointsImpl.call(a, 2, b);\r\n    return (strict && ((value !== 0 && rangeIntersects(a, b)) || (value === 0 && !rangeEquals(a, b)))) ? NaN : value && value / Math.abs(value);\r\n}\r\n\r\nfunction makeSelection(b, e) {\r\n    if (!selection) {\r\n        return;\r\n    }\r\n    // for newer browsers that supports setBaseAndExtent\r\n    // avoid undesirable effects when direction of editor's selection direction does not match native one\r\n    if (selection.setBaseAndExtent && is(e, Range)) {\r\n        selection.setBaseAndExtent(b.startContainer, b.startOffset, e.startContainer, e.startOffset);\r\n        return;\r\n    }\r\n\r\n    var range = createRange(b, e);\r\n    try {\r\n        selection.removeAllRanges();\r\n    } catch (e) {\r\n        // IE fails to clear ranges by removeAllRanges() in occasions mentioned in\r\n        // http://stackoverflow.com/questions/22914075\r\n        // @ts-ignore: non-standard member\r\n        var r = document.body.createTextRange();\r\n        r.collapse();\r\n        r.select();\r\n        selection.removeAllRanges();\r\n    }\r\n    try {\r\n        selection.addRange(range);\r\n    } catch (e) {\r\n        // IE may throws unspecified error even though the selection is successfully moved to the given range\r\n        // if the range is not successfully selected retry after selecting other range\r\n        if (!selection.rangeCount) {\r\n            selection.addRange(createRange(document.body));\r\n            selection.removeAllRanges();\r\n            selection.addRange(range);\r\n        }\r\n    }\r\n}\r\n\r\nfunction getRect(elm, includeMargin) {\r\n    var rect;\r\n    elm = elm || root;\r\n    if (elm.getRect) {\r\n        return elm.getRect();\r\n    }\r\n    elm = elm.element || elm;\r\n    if (elm === root || elm === window) {\r\n        var div = originDiv || (originDiv = $('<div style=\"position:fixed; top:0; left:0;\">')[0]);\r\n        if (!containsOrEquals(document.body, div)) {\r\n            document.body.appendChild(div);\r\n        }\r\n        // origin used by CSS, DOMRect and properties like clientX/Y may move away from the top-left corner of the window\r\n        // when virtual keyboard is shown on mobile devices\r\n        var o = getRect(div);\r\n        rect = toPlainRect(0, 0, root.offsetWidth, root.offsetHeight).translate(o.left, o.top);\r\n    } else if (!containsOrEquals(root, elm)) {\r\n        // IE10 throws Unspecified Error for detached elements\r\n        rect = toPlainRect(0, 0, 0, 0);\r\n    } else {\r\n        rect = toPlainRect(elm.getBoundingClientRect());\r\n        if (includeMargin) {\r\n            var style = getComputedStyle(elm);\r\n            rect.top -= Math.max(0, parseFloat(style.marginTop));\r\n            rect.left -= Math.max(0, parseFloat(style.marginLeft));\r\n            rect.right += Math.max(0, parseFloat(style.marginRight));\r\n            rect.bottom += Math.max(0, parseFloat(style.marginBottom));\r\n        }\r\n    }\r\n    return rect;\r\n}\r\n\r\nfunction getOffset(node, offset) {\r\n    var len = node.length || node.childNodes.length;\r\n    return 1 / offset < 0 ? Math.max(0, len + offset) : Math.min(len, offset);\r\n}\r\n\r\nfunction getRects(range) {\r\n    return map((is(range, Range) || createRange(range, 'contents')).getClientRects(), toPlainRect);\r\n}\r\n\r\nfunction toPlainRect(l, t, r, b) {\r\n    function clip(v) {\r\n        // IE provides precision up to 0.05 but with floating point errors that hinder comparisons\r\n        return Math.round(v * 1000) / 1000;\r\n    }\r\n    if (l.top !== undefined) {\r\n        return new Rect(clip(l.left), clip(l.top), clip(l.right), clip(l.bottom));\r\n    }\r\n    if (r === undefined) {\r\n        return new Rect(l, t, l, t);\r\n    }\r\n    return new Rect(l, t, r, b);\r\n}\r\n\r\nfunction rectEquals(a, b) {\r\n    function check(prop) {\r\n        return Math.abs(a[prop] - b[prop]) < 1;\r\n    }\r\n    return check('left') && check('top') && check('bottom') && check('right');\r\n}\r\n\r\nfunction rectCovers(a, b) {\r\n    return b.left >= a.left && b.right <= a.right && b.top >= a.top && b.bottom <= a.bottom;\r\n}\r\n\r\nfunction rectIntersects(a, b) {\r\n    return !(b.right < a.left || b.left > a.right) && !(b.bottom < a.top || b.top > a.bottom);\r\n}\r\n\r\nfunction pointInRect(x, y, rect, within) {\r\n    within = within || 0;\r\n    return rect.width && rect.height && x - rect.left >= -within && x - rect.right <= within && y - rect.top >= -within && y - rect.bottom <= within;\r\n}\r\n\r\nfunction mergeRect(a, b) {\r\n    return toPlainRect(Math.min(a.left, b.left), Math.min(a.top, b.top), Math.max(a.right, b.right), Math.max(a.bottom, b.bottom));\r\n}\r\n\r\nfunction elementFromPoint(x, y, container) {\r\n    container = container || document.body;\r\n    if (elementsFromPoint) {\r\n        return any(elementsFromPoint.call(document, x, y), function (v) {\r\n            return containsOrEquals(container, v) && getComputedStyle(v).pointerEvents !== 'none';\r\n        }) || null;\r\n    }\r\n    var element = document.elementFromPoint(x, y);\r\n    if (!containsOrEquals(container, element) && pointInRect(x, y, getRect(container))) {\r\n        var tmp = [];\r\n        try {\r\n            while (element && comparePosition(container, element, true)) {\r\n                var target = $(element).parentsUntil(getCommonAncestor(container, element)).slice(-1)[0] || element;\r\n                if (target === tmp[tmp.length - 1]) {\r\n                    return null;\r\n                }\r\n                // @ts-ignore: assume we are working with HTMLElement\r\n                target.style.pointerEvents = 'none';\r\n                tmp[tmp.length] = target;\r\n                element = document.elementFromPoint(x, y);\r\n            }\r\n        } finally {\r\n            $(tmp).css('pointer-events', '');\r\n        }\r\n    }\r\n    return containsOrEquals(container, element) ? element : null;\r\n}\r\n\r\n\r\nexport {\r\n    tagName,\r\n    is,\r\n    isVisible,\r\n    sameElementSpec,\r\n    comparePosition,\r\n    connected,\r\n    containsOrEquals,\r\n    iterateNode,\r\n    iterateNodeToArray,\r\n\r\n    getCommonAncestor,\r\n    parentsAndSelf,\r\n    selectIncludeSelf,\r\n    selectClosestRelative,\r\n\r\n    createDocumentFragment,\r\n    createTextNode,\r\n    createElement,\r\n    createNodeIterator,\r\n\r\n    bind,\r\n    dispatchDOMMouseEvent,\r\n\r\n    removeNode,\r\n    getClass,\r\n    setClass,\r\n    getScrollOffset,\r\n    scrollBy,\r\n\r\n    createRange,\r\n    rangeIntersects,\r\n    rangeEquals,\r\n    rangeCovers,\r\n    compareRangePosition,\r\n    makeSelection,\r\n\r\n    getRect,\r\n    getRects,\r\n    toPlainRect,\r\n    rectEquals,\r\n    rectCovers,\r\n    rectIntersects,\r\n    pointInRect,\r\n    mergeRect,\r\n    elementFromPoint\r\n};\r\n","import { getClass, setClass, iterateNode, createNodeIterator, isVisible, bind } from \"./domUtil.js\";\r\nimport { reject, noop, resolve, each, matchWord, keys } from \"./util.js\";\r\n\r\nfunction parseCSS(value) {\r\n    var styles = {};\r\n    var div = document.createElement('div');\r\n    div.setAttribute('style', value);\r\n    each(div.style, function (i, v) {\r\n        styles[v] = div.style[v];\r\n    });\r\n    return styles;\r\n}\r\n\r\nfunction isCssUrlValue(value) {\r\n    return value && value !== 'none' && /url\\((?:'(.+)'|\"(.+)\"|([^)]+))\\)/.test(value) && (RegExp.$1 || RegExp.$2 || RegExp.$3);\r\n}\r\n\r\nfunction styleToJSON(style) {\r\n    var t = {};\r\n    each(style, function (i, v) {\r\n        t[v] = style[v];\r\n    });\r\n    return t;\r\n}\r\n\r\nfunction animatableValue(v, allowNumber) {\r\n    return /\\b(?:[+-]?(\\d+(?:\\.\\d+)?)(px|%)?|#[0-9a-f]{3,}|(rgba?|hsla?|matrix|calc)\\(.+\\))\\b/.test(v) && (allowNumber || !RegExp.$1 || RegExp.$2);\r\n}\r\n\r\nfunction removeVendorPrefix(name) {\r\n    return name.replace(/^-(webkit|moz|ms|o)-/, '');\r\n}\r\n\r\nfunction runCSSTransition(element, className, callback) {\r\n    if (getClass(element, className)) {\r\n        return reject();\r\n    }\r\n    callback = callback || noop;\r\n    if (callback === true) {\r\n        callback = setClass.bind(null, element, className, false);\r\n    }\r\n    setClass(element, className, true);\r\n    var arr = [];\r\n    var map1 = new Map();\r\n    var test = function (element, pseudoElement) {\r\n        var style = getComputedStyle(element, pseudoElement);\r\n        if (style.transitionDuration !== '0s' || style.animationName != 'none') {\r\n            var key = { element: element, pseudoElement: pseudoElement };\r\n            map1.set(key, style.transitionProperty.split(/,\\s*/));\r\n            arr.push(key);\r\n        }\r\n    };\r\n    iterateNode(createNodeIterator(element, 1, function (v) {\r\n        if (!isVisible(v)) {\r\n            return 2;\r\n        }\r\n        test(v, null);\r\n        test(v, '::before');\r\n        test(v, '::after');\r\n    }));\r\n    if (!arr[0]) {\r\n        callback();\r\n        return resolve();\r\n    }\r\n\r\n    var targets = arr.map(function (v) {\r\n        return v.element;\r\n    });\r\n    setClass(element, className, false);\r\n    $(targets).css('transition', 'none');\r\n    setClass(element, className, true);\r\n    var newStyle = arr.map(function (v) {\r\n        return styleToJSON(getComputedStyle(v.element, v.pseudoElement));\r\n    });\r\n    setClass(element, className, false);\r\n\r\n    var appendPseudoToAnim = window.AnimationEvent && 'pseudoElement' in AnimationEvent.prototype;\r\n    var map = new Map();\r\n    each(arr, function (i, v) {\r\n        var pseudoElement = v.pseudoElement;\r\n        var curStyle = getComputedStyle(v.element, pseudoElement);\r\n        var transitionProperties = map1.get(v);\r\n        var dict = {};\r\n        each(curStyle, function (j, v) {\r\n            var curValue = curStyle[v];\r\n            var newValue = newStyle[i][v];\r\n            if (curValue === 'matrix(1, 0, 0, 1, 0, 0)') {\r\n                curValue = 'none';\r\n            }\r\n            if (newValue === 'matrix(1, 0, 0, 1, 0, 0)') {\r\n                newValue = 'none';\r\n            }\r\n            if (curValue !== newValue) {\r\n                var prop = removeVendorPrefix(v);\r\n                var allowNumber = matchWord(v, 'opacity line-height');\r\n                if (prop === 'animation-name') {\r\n                    var prevAnim = curValue.replace(/,/g, '');\r\n                    each(newValue.split(/,\\s*/), function (i, v) {\r\n                        if (v !== 'none' && !matchWord(prevAnim, v)) {\r\n                            dict['@' + v + ((appendPseudoToAnim && pseudoElement) || '')] = true;\r\n                        }\r\n                    });\r\n                } else if (prop === 'transform' || (animatableValue(curValue, allowNumber) && animatableValue(newValue, allowNumber) && !/^scroll-limit/.test(prop))) {\r\n                    if (transitionProperties[0] === 'all' || transitionProperties.indexOf(v + (pseudoElement || '')) >= 0) {\r\n                        dict[prop + (pseudoElement || '')] = true;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        if (keys(dict)[0]) {\r\n            map.set(v.element, dict);\r\n        }\r\n    });\r\n    $(targets).css('transition', '');\r\n    setClass(element, className, true);\r\n    if (!map.size) {\r\n        callback();\r\n        return resolve();\r\n    }\r\n\r\n    return new Promise(function (resolve, reject) {\r\n        var unbind = bind(element, 'animationend transitionend', function (e) {\r\n            var dict = map.get(e.target) || {};\r\n            // @ts-ignore: mixed type of Event\r\n            delete dict[(e.propertyName ? removeVendorPrefix(e.propertyName) : '@' + e.animationName) + (e.pseudoElement || '')];\r\n            if (!keys(dict)[0] && map.delete(e.target) && !map.size) {\r\n                unbind();\r\n                if (getClass(element, className)) {\r\n                    callback();\r\n                    resolve(element);\r\n                } else {\r\n                    reject(element);\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport {\r\n    parseCSS,\r\n    isCssUrlValue,\r\n    runCSSTransition\r\n\r\n    // getZIndex: getZIndex,\r\n    // getZIndexOver: getZIndexOver,\r\n    // setZIndexOver: setZIndexOver,\r\n    // cssFromPoint: cssFromPoint,\r\n    // cssFromRect: cssFromRect,\r\n    // position: position,\r\n    // snap:  (element, to, dir)\r\n    // unsnap:  (element)\r\n    // drag:  drag(event, within, callback)\r\n    // scrollIntoView:  scrollIntoView(element, rect)\r\n};\r\n","import { createPrivateStore, definePrototype, each, extend, isFunction, isPlainObject, kv, makeArray, mapGet, matchWord, randomId, reject, resolve, single } from \"./util.js\";\r\nimport { containsOrEquals, is, parentsAndSelf } from \"./domUtil.js\";\r\nimport dom from \"./dom.js\";\r\n\r\nconst root = document.documentElement;\r\nconst containers = new WeakMap();\r\nconst domEventTrap = new ZetaContainer();\r\nconst domContainer = new ZetaContainer();\r\nconst _ = createPrivateStore();\r\n\r\nexport var eventSource;\r\nexport var lastEventSource;\r\n\r\n\r\n/* --------------------------------------\r\n * Helper functions\r\n * -------------------------------------- */\r\n\r\n/** @type {Zeta.ZetaComponentConstructor} */\r\nfunction ZetaComponent() {\r\n    this.states = {};\r\n}\r\n\r\nfunction ZetaEventHandlerState(element, context, handlers) {\r\n    var self = this;\r\n    var copy = {};\r\n    each(handlers, function (i, v) {\r\n        if (isFunction(v)) {\r\n            copy[i] = v;\r\n        }\r\n    });\r\n    self.element = element;\r\n    self.context = context;\r\n    self.handlers = copy;\r\n}\r\n\r\nfunction ZetaEventSource(target, path) {\r\n    var self = this;\r\n    path = path || (eventSource ? eventSource.path : dom.focusedElements);\r\n    self.path = path;\r\n    self.source = 'script';\r\n    if (containsOrEquals(path[0] || root, target) || path.indexOf(target) >= 0) {\r\n        self.source = eventSource ? eventSource.source : getEventSourceName();\r\n    }\r\n    self.sourceKeyName = self.source !== 'keyboard' ? null : (eventSource || lastEventSource || '').sourceKeyName;\r\n}\r\n\r\nfunction setLastEventSource(source) {\r\n    lastEventSource = new ZetaEventSource(source);\r\n}\r\n\r\nfunction prepEventSource(promise) {\r\n    var source = eventSource || new ZetaEventSource(dom.activeElement);\r\n    var wrap = function (callback) {\r\n        return function () {\r\n            var prev = eventSource;\r\n            try {\r\n                eventSource = source;\r\n                return callback.apply(this, arguments);\r\n            } finally {\r\n                eventSource = prev;\r\n            }\r\n        };\r\n    };\r\n    return {\r\n        then: function (a, b) {\r\n            return promise.then(a && wrap(a), b && wrap(b));\r\n        },\r\n        catch: function (a) {\r\n            return promise.catch(a && wrap(a));\r\n        }\r\n    };\r\n}\r\n\r\nfunction getEventSource(element) {\r\n    return element ? new ZetaEventSource(element).source : getEventSourceName();\r\n}\r\n\r\nfunction getEventSourceName() {\r\n    var event = dom.event || window.event;\r\n    var type = (event && event.type) || '';\r\n    return type[0] === 'k' || type.substr(0, 3) === 'com' ? 'keyboard' : type[0] === 't' ? 'touch' : type[0] === 'm' || matchWord(type, 'wheel click dblclick contextmenu') ? 'mouse' : matchWord(type, 'drop cut copy paste') || 'script';\r\n}\r\n\r\nfunction getContainer(element, exact) {\r\n    if (exact) {\r\n        return mapGet(containers, element);\r\n    }\r\n    for (var cur = element; cur && !containers.has(cur); cur = cur.parentNode);\r\n    return mapGet(containers, cur) || domContainer;\r\n}\r\n\r\nfunction emitEvent(eventName, container, target, data, bubbles) {\r\n    var event = is(eventName, ZetaEvent) ? _(eventName) : new ZetaEventEmitter(eventName, container, target, data, null, bubbles);\r\n    return event.emit(container, null, target, bubbles);\r\n}\r\n\r\nfunction emitDOMEvent(eventName, nativeEvent, target, data, bubbles, source) {\r\n    var event = new ZetaEventEmitter(eventName, domContainer, target, data, nativeEvent, bubbles, source);\r\n    return event.emit(domEventTrap, 'tap', getContainer(target).element, false) || event.emit();\r\n}\r\n\r\nfunction listenDOMEvent(element, event, handler) {\r\n    if (!is(element, Node)) {\r\n        handler = event;\r\n        event = element;\r\n        element = root;\r\n    }\r\n    domContainer.setContext(element, element);\r\n    domContainer.add(element, isPlainObject(event) || kv(event, handler));\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * ZetaEventEmitter\r\n * -------------------------------------- */\r\n\r\nfunction ZetaEventEmitter(eventName, container, target, data, originalEvent, bubbles, source) {\r\n    target = target || container.element;\r\n    source = source || new ZetaEventSource(target);\r\n    var properties = {\r\n        source: source.source,\r\n        sourceKeyName: source.sourceKeyName,\r\n        timestamp: performance.now(),\r\n        originalEvent: originalEvent || null\r\n    };\r\n    extend(this, {\r\n        container: container,\r\n        eventName: eventName,\r\n        target: target,\r\n        data: data,\r\n        bubbles: bubbles,\r\n        properties: properties,\r\n        sourceObj: source\r\n    }, properties);\r\n}\r\n\r\ndefinePrototype(ZetaEventEmitter, {\r\n    emit: function (container, eventName, target, bubbles) {\r\n        var self = this;\r\n        container = container || self.container;\r\n        bubbles = bubbles === undefined ? self.bubbles : bubbles;\r\n\r\n        var callHandler = function (state, handlerName, eventName, data) {\r\n            if (handlerName === 'init' || handlerName === 'destroy') {\r\n                // prevent init and destroy event from called consecutively twice\r\n                if (state.lastEvent === handlerName) {\r\n                    return false;\r\n                }\r\n                state.lastEvent = handlerName;\r\n            }\r\n            if (matchWord(handlerName || eventName, 'keystroke gesture') && callHandler(state, null, data.data, null)) {\r\n                return self.handled;\r\n            }\r\n            var handler = state.handlers[handlerName || eventName];\r\n            if (!handler) {\r\n                return false;\r\n            }\r\n            var contextContainer = is(state.context, ZetaContainer) || container;\r\n            var event = new ZetaEvent(self, eventName, state, data === undefined ? containerRemoveAsyncEvent(container, eventName, state) : data);\r\n            var prevEventSource = eventSource;\r\n            var prevEvent = contextContainer.event;\r\n            contextContainer.event = event;\r\n            eventSource = self.sourceObj;\r\n            try {\r\n                var returnValue = handler.call(event.context, event, event.context);\r\n                if (returnValue !== undefined) {\r\n                    // @ts-ignore: type inference issue\r\n                    self.handled = resolve(returnValue);\r\n                }\r\n            } catch (e) {\r\n                console.error(e);\r\n                // @ts-ignore: type inference issue\r\n                self.handled = reject(e);\r\n            }\r\n            eventSource = prevEventSource;\r\n            contextContainer.event = prevEvent;\r\n            return self.handled;\r\n        };\r\n        if (is(target, ZetaEventHandlerState)) {\r\n            return callHandler(target, eventName, self.eventName, self.data);\r\n        }\r\n        // find the nearest ancestor that has widget or context set\r\n        var context = container.getContext(target || self.target);\r\n        return single((bubbles ? parentsAndSelf : makeArray)(context), function (v) {\r\n            var component = container.components.get(v.element || v);\r\n            return component && single(component.states, function (v) {\r\n                return callHandler(v, eventName, self.eventName, self.data);\r\n            });\r\n        });\r\n    }\r\n});\r\n\r\n\r\n/* --------------------------------------\r\n * ZetaEvent\r\n * -------------------------------------- */\r\n\r\nfunction ZetaEvent(event, eventName, state, data) {\r\n    var self = extend(this, event.properties);\r\n    self.eventName = eventName;\r\n    self.type = eventName;\r\n    self.context = state.context;\r\n    self.target = containsOrEquals(event.target, state.element) ? state.element : event.target;\r\n    self.data = null;\r\n    if (isPlainObject(data)) {\r\n        extend(self, data);\r\n    } else if (data !== undefined) {\r\n        self.data = data;\r\n    }\r\n    _(self, event);\r\n}\r\n\r\ndefinePrototype(ZetaEvent, {\r\n    handled: function (promise) {\r\n        var event = _(this);\r\n        if (!event.handled) {\r\n            event.handled = resolve(promise);\r\n        }\r\n    },\r\n    isHandled: function () {\r\n        return !!_(this).handled;\r\n    },\r\n    preventDefault: function () {\r\n        var event = this.originalEvent;\r\n        if (event) {\r\n            event.preventDefault();\r\n        } else {\r\n            _(this).defaultPrevented = true;\r\n        }\r\n    },\r\n    isDefaultPrevented: function () {\r\n        return !!(this.originalEvent || _(this)).defaultPrevented;\r\n    }\r\n});\r\n\r\n\r\n/* --------------------------------------\r\n * ZetaContainer\r\n * -------------------------------------- */\r\n\r\nfunction ZetaContainer(element, context) {\r\n    var self = this;\r\n    if (element) {\r\n        containers.set(element, self);\r\n    }\r\n    self.element = element || root;\r\n    self.context = context || null;\r\n    self.components = new Map();\r\n    self.asyncEvents = new Map();\r\n    self.autoDestroy = containsOrEquals(root, element);\r\n    if (element) {\r\n        containers.set(element, self);\r\n    }\r\n}\r\n\r\ndefinePrototype(ZetaContainer, {\r\n    event: null,\r\n    tap: function (handler) {\r\n        domEventTrap.setContext(this.element, this);\r\n        domEventTrap.add(this.element, {\r\n            tap: handler\r\n        });\r\n    },\r\n    getContext: function (element) {\r\n        return (containerGetContext(this, element) || '').context;\r\n    },\r\n    setContext: function (element, context) {\r\n        containerSetContext(this, element, context);\r\n        if (this !== domEventTrap && is(element, Node)) {\r\n            containers.set(element, this);\r\n        }\r\n    },\r\n    add: function (element, key, handlers) {\r\n        if (typeof key !== 'string') {\r\n            handlers = key;\r\n            key = randomId();\r\n        }\r\n        var self = this;\r\n        var target = is(element, Node) || element.element || element;\r\n        var component = is(target, Node) ? containerGetContext(self, target) : containerSetContext(self, element, element);\r\n        if (component) {\r\n            var state = component.states[key] || new ZetaEventHandlerState(target, is(element, Node) ? component.context : element, handlers);\r\n            component.attached = true;\r\n            component.states[key] = state;\r\n            containerRegisterWidgetEvent(self, state, true);\r\n        }\r\n    },\r\n    delete: function (element, key) {\r\n        var self = this;\r\n        var component = mapGet(self.components, element);\r\n        if (component) {\r\n            if (key) {\r\n                var state = component.states[key];\r\n                if (state) {\r\n                    delete component.states[key];\r\n                    containerRegisterWidgetEvent(self, state, false);\r\n                }\r\n            } else {\r\n                component.attached = false;\r\n                each(component.states, function (i, v) {\r\n                    containerRegisterWidgetEvent(self, v, false);\r\n                });\r\n            }\r\n        }\r\n    },\r\n    observe: function (callback, options) {\r\n        return containerCreateObserver(this, callback, options);\r\n    },\r\n    emit: function (eventName, target, data, bubbles) {\r\n        return emitEvent(eventName, this, data, target, bubbles);\r\n    },\r\n    emitAsync: function (event, target, data, bubbles, mergeData) {\r\n        containerRegisterAsyncEvent(this, event, target || this.element, data, bubbles, mergeData);\r\n    },\r\n    flushEvents: function () {\r\n        containerEmitAsyncEvents(this);\r\n    },\r\n    destroy: function () {\r\n        var self = this;\r\n        domEventTrap.delete(self.element);\r\n        containers.delete(self.element);\r\n        each(self.components, function (i, v) {\r\n            containers.delete(i);\r\n            self.emit('destroy', i);\r\n        });\r\n    }\r\n});\r\n\r\n\r\nfunction containerEmitAsyncEvents(inst) {\r\n    inst.timeout = null;\r\n    while (inst.asyncEvents.size) {\r\n        var map = inst.asyncEvents;\r\n        inst.asyncEvents = new Map();\r\n        each(map, function (i, v) {\r\n            each(v, function (j, v) {\r\n                if (!isPlainObject(i) || i.handlers[j]) {\r\n                    v.emit(null, null, i);\r\n                }\r\n            });\r\n        });\r\n        each(map, function (i, v) {\r\n            var obj = mapGet(inst.components, i.element || i);\r\n            if (obj && !obj.attached) {\r\n                inst.components.delete(i.element || i);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction containerRemoveAsyncEvent(inst, eventName, target) {\r\n    var obj = mapGet(inst.asyncEvents, target);\r\n    if (obj && obj[eventName]) {\r\n        var data = obj[eventName].data;\r\n        delete obj[eventName];\r\n        return data || {\r\n            data: data\r\n        };\r\n    }\r\n}\r\n\r\nfunction containerRegisterAsyncEvent(inst, eventName, target, data, bubbles, mergeData) {\r\n    var obj = mapGet(inst.asyncEvents, target, Object);\r\n    obj[eventName] = new ZetaEventEmitter(eventName, inst, target.element || target, mergeData && obj[eventName] ? mergeData(obj[eventName].data, data) : data, null, bubbles);\r\n    inst.timeout = inst.timeout || setTimeout(containerEmitAsyncEvents, 0, inst);\r\n}\r\n\r\nfunction containerRegisterWidgetEvent(container, state, isInit) {\r\n    var event = ['destroy', 'init'];\r\n    if (state.attached ^ isInit && !containerRemoveAsyncEvent(container, event[+!isInit], state)) {\r\n        containerRegisterAsyncEvent(container, event[+isInit], state);\r\n    }\r\n    state.attached = isInit;\r\n}\r\n\r\nfunction containerValidTarget(container, element) {\r\n    return container === domEventTrap || (containers.get(element) || container) === container;\r\n}\r\n\r\nfunction containerCreateObserver(container, callback, options) {\r\n    function handleMutations(mutations) {\r\n        var changes = [];\r\n        var orphans = new Map();\r\n        each(mutations, function (i, v) {\r\n            // filter out changes due to sizzle engine\r\n            // to prevent excessive invocation due to querying elements through jQuery\r\n            if (v.attributeName !== 'id' || ((v.oldValue || '').slice(0, 6) !== 'sizzle' && (v.target.id !== (v.oldValue || '')))) {\r\n                if (!containsOrEquals(container.element, v.target)) {\r\n                    mapGet(orphans, v.target, Array).push(v);\r\n                } else if (containerValidTarget(container, v.target)) {\r\n                    each(v.removedNodes, function (i, v) {\r\n                        if (orphans.has(v)) {\r\n                            changes.push.apply(changes, orphans.get(v));\r\n                        }\r\n                    });\r\n                    changes.push(v);\r\n                }\r\n            }\r\n        });\r\n        changes = changes.filter(function (v) {\r\n            return options[v.type];\r\n        });\r\n        if (changes[0]) {\r\n            callback(changes);\r\n        }\r\n    }\r\n\r\n    var moptions = extend({}, options);\r\n    moptions.subtree = true;\r\n    moptions.childList = true;\r\n    moptions.attributeOldValue |= options.attributes;\r\n\r\n    var observer = new MutationObserver(handleMutations);\r\n    observer.observe(container.element, moptions);\r\n    return function () {\r\n        handleMutations(observer.takeRecords());\r\n    };\r\n}\r\n\r\nfunction containerGetContext(inst, element) {\r\n    var component;\r\n    for (var cur = element; cur && !component; cur = cur.parentNode) {\r\n        component = inst.components.get(cur);\r\n    }\r\n    return component || null;\r\n}\r\n\r\nfunction containerSetContext(inst, element, context) {\r\n    var cur = mapGet(inst.components, element, ZetaComponent);\r\n    // @ts-ignore: undeclared property added to ZetaComponent\r\n    if ((cur.context || context) !== context) {\r\n        throw new Error('Element has already been set to another context');\r\n    }\r\n    // @ts-ignore: undeclared property added to ZetaComponent\r\n    cur.element = element;\r\n    // @ts-ignore: undeclared property added to ZetaComponent\r\n    cur.context = context;\r\n    return cur;\r\n}\r\n\r\nexport {\r\n    ZetaEventSource,\r\n    emitEvent,\r\n    emitDOMEvent,\r\n    listenDOMEvent,\r\n    getContainer,\r\n    getEventSource,\r\n    prepEventSource,\r\n    setLastEventSource\r\n};\r\n","import { Map, WeakMap, Promise } from \"./shim.js\";\r\nimport { any, createPrivateStore, definePrototype, extend, makeArray, mapRemove, reject, resolve } from \"./util.js\";\r\nimport { parentsAndSelf } from \"./domUtil.js\";\r\nimport { emitDOMEvent } from \"./events.js\";\r\n\r\nconst lockedElements = new WeakMap();\r\nconst handledErrors = new WeakMap();\r\nconst _ = createPrivateStore();\r\n\r\nfunction retryable(fn, done) {\r\n    var promise;\r\n    return function () {\r\n        return promise || (promise = resolve(fn()).then(done, function () {\r\n            // user has rejected the cancellation\r\n            // remove the promise object so that user will be prompted again\r\n            promise = null;\r\n            return reject('user_cancelled');\r\n        }));\r\n    };\r\n}\r\n\r\nfunction lock(element, promise, oncancel) {\r\n    var lock = lockedElements.get(element) || new DOMLock(element);\r\n    return promise ? lock.wait(promise, oncancel) : resolve();\r\n}\r\n\r\nfunction locked(element, parents) {\r\n    return !!any(parents ? parentsAndSelf(element) : [element], function (v) {\r\n        return (lockedElements.get(v) || '').locked;\r\n    });\r\n}\r\n\r\nfunction cancelLock(element, force) {\r\n    var lock = lockedElements.get(element);\r\n    return lock ? lock.cancel(force) : resolve();\r\n}\r\n\r\nfunction removeLock(element) {\r\n    var lock = mapRemove(lockedElements, element);\r\n    if (lock) {\r\n        lock.cancel(true);\r\n    }\r\n}\r\n\r\nfunction DOMLock(element) {\r\n    this.element = element;\r\n    lockedElements.set(element, this);\r\n    _(this, { promises: new Map() });\r\n}\r\n\r\ndefinePrototype(DOMLock, {\r\n    get locked() {\r\n        return _(this).promises.size > 0;\r\n    },\r\n    cancel: function (force) {\r\n        var self = this;\r\n        var state = _(self);\r\n        var promises = state.promises;\r\n        if (force || !promises.size) {\r\n            if (promises.size) {\r\n                // @ts-ignore: unable to reflect on interface member\r\n                emitDOMEvent('cancelled', null, self.element);\r\n            }\r\n            // remove all promises from the dictionary so that\r\n            // filtered promise from lock.wait() will be rejected by cancellation\r\n            promises.clear();\r\n            state.handler = null;\r\n            if (state.deferred) {\r\n                state.deferred.resolve();\r\n            }\r\n            return resolve();\r\n        }\r\n        return (state.handler || (state.handler = retryable(function () {\r\n            // request user cancellation for each async task in sequence\r\n            return makeArray(promises).reduce(function (a, v) {\r\n                return a.then(v);\r\n            }, resolve()).then(function () {\r\n                // @ts-ignore: unable to reflect on interface member\r\n                self.cancel(true);\r\n            });\r\n        })))();\r\n    },\r\n    wait: function (promise, oncancel) {\r\n        var self = this;\r\n        var state = _(self);\r\n        var promises = state.promises;\r\n        var finish = function () {\r\n            if (promises.delete(promise) && !promises.size) {\r\n                emitDOMEvent('asyncEnd', null, self.element);\r\n                self.cancel(true);\r\n            }\r\n        };\r\n        promises.set(promise, retryable(oncancel === true ? resolve : oncancel || reject, finish));\r\n        if (promises.size === 1) {\r\n            var callback = {};\r\n            var deferred = new Promise(function (resolve, reject) {\r\n                callback.resolve = resolve;\r\n                callback.reject = reject;\r\n            });\r\n            state.deferred = extend(deferred, callback);\r\n            for (var parent = self.element.parentNode; parent && !lockedElements.has(parent); parent = parent.parentNode);\r\n            if (parent) {\r\n                lockedElements.get(parent).wait(deferred, self.cancel.bind(self));\r\n            }\r\n            emitDOMEvent('asyncStart', null, self.element);\r\n        }\r\n        promise.catch(function (error) {\r\n            if (error && !handledErrors.has(error)) {\r\n                emitDOMEvent('error', null, self.element, {\r\n                    error: error\r\n                }, true);\r\n                // avoid firing error event for the same error for multiple target\r\n                // while propagating through the promise chain\r\n                if (typeof error === 'object') {\r\n                    handledErrors.set(error, true);\r\n                }\r\n            }\r\n            finish();\r\n        });\r\n        return promise.then(function (value) {\r\n            var cancelled = !promises.has(promise);\r\n            finish();\r\n            // the returned promise will be rejected\r\n            // if the current lock has been released or cancelled\r\n            return cancelled ? reject('user_cancelled') : value;\r\n        });\r\n    }\r\n});\r\n\r\nlock(document);\r\nwindow.onbeforeunload = function (e) {\r\n    if (locked(document)) {\r\n        e.returnValue = '';\r\n        e.preventDefault();\r\n    }\r\n};\r\n\r\nexport {\r\n    lock,\r\n    locked,\r\n    cancelLock,\r\n    removeLock\r\n};\r\n","import { IS_IE10, IS_MAC, IS_TOUCH } from \"./env.js\";\r\nimport { Map, Set, WeakMap, Promise, $ } from \"./shim.js\";\r\nimport { any, each, extend, lcfirst, makeArray, map, mapRemove, matchWord, single, ucfirst } from \"./util.js\";\r\nimport { bind, containsOrEquals, dispatchDOMMouseEvent, getRect, is, isVisible, makeSelection, parentsAndSelf, removeNode, scrollBy, selectIncludeSelf } from \"./domUtil.js\";\r\nimport { ZetaEventSource, lastEventSource, getContainer, setLastEventSource, getEventSource, emitDOMEvent, listenDOMEvent } from \"./events.js\";\r\nimport { lock, cancelLock, locked, removeLock } from \"./domLock.js\";\r\n\r\nconst KEYNAMES = JSON.parse('{\"8\":\"backspace\",\"9\":\"tab\",\"13\":\"enter\",\"16\":\"shift\",\"17\":\"ctrl\",\"18\":\"alt\",\"19\":\"pause\",\"20\":\"capsLock\",\"27\":\"escape\",\"32\":\"space\",\"33\":\"pageUp\",\"34\":\"pageDown\",\"35\":\"end\",\"36\":\"home\",\"37\":\"leftArrow\",\"38\":\"upArrow\",\"39\":\"rightArrow\",\"40\":\"downArrow\",\"45\":\"insert\",\"46\":\"delete\",\"48\":\"0\",\"49\":\"1\",\"50\":\"2\",\"51\":\"3\",\"52\":\"4\",\"53\":\"5\",\"54\":\"6\",\"55\":\"7\",\"56\":\"8\",\"57\":\"9\",\"65\":\"a\",\"66\":\"b\",\"67\":\"c\",\"68\":\"d\",\"69\":\"e\",\"70\":\"f\",\"71\":\"g\",\"72\":\"h\",\"73\":\"i\",\"74\":\"j\",\"75\":\"k\",\"76\":\"l\",\"77\":\"m\",\"78\":\"n\",\"79\":\"o\",\"80\":\"p\",\"81\":\"q\",\"82\":\"r\",\"83\":\"s\",\"84\":\"t\",\"85\":\"u\",\"86\":\"v\",\"87\":\"w\",\"88\":\"x\",\"89\":\"y\",\"90\":\"z\",\"91\":\"leftWindow\",\"92\":\"rightWindowKey\",\"93\":\"select\",\"96\":\"numpad0\",\"97\":\"numpad1\",\"98\":\"numpad2\",\"99\":\"numpad3\",\"100\":\"numpad4\",\"101\":\"numpad5\",\"102\":\"numpad6\",\"103\":\"numpad7\",\"104\":\"numpad8\",\"105\":\"numpad9\",\"106\":\"multiply\",\"107\":\"add\",\"109\":\"subtract\",\"110\":\"decimalPoint\",\"111\":\"divide\",\"112\":\"f1\",\"113\":\"f2\",\"114\":\"f3\",\"115\":\"f4\",\"116\":\"f5\",\"117\":\"f6\",\"118\":\"f7\",\"119\":\"f8\",\"120\":\"f9\",\"121\":\"f10\",\"122\":\"f11\",\"123\":\"f12\",\"144\":\"numLock\",\"145\":\"scrollLock\",\"186\":\"semiColon\",\"187\":\"equalSign\",\"188\":\"comma\",\"189\":\"dash\",\"190\":\"period\",\"191\":\"forwardSlash\",\"192\":\"backtick\",\"219\":\"openBracket\",\"220\":\"backSlash\",\"221\":\"closeBracket\",\"222\":\"singleQuote\"}');\r\nconst SELECTOR_FOCUSABLE = ':input, [contenteditable], a[href], area[href], iframe';\r\nconst META_KEYS = [16, 17, 18, 91, 93];\r\nconst OFFSET_ZERO = {\r\n    x: 0,\r\n    y: 0\r\n};\r\n\r\nconst root = document.documentElement;\r\nconst selection = window.getSelection();\r\nconst focusPath = [];\r\nconst focusFriends = new WeakMap();\r\nconst focusElements = new Set();\r\nconst modalElements = new Map();\r\nconst domReady = new Promise($);\r\n\r\nvar windowFocusedOut;\r\nvar currentEvent;\r\nvar scrollbarWidth;\r\n\r\n\r\n/* --------------------------------------\r\n * Helper functions\r\n * -------------------------------------- */\r\n\r\nfunction approxMultipleOf(a, b) {\r\n    return Math.abs(Math.round(a / b) - a / b) < 0.2;\r\n}\r\n\r\nfunction measureLine(p1, p2) {\r\n    var dx = p1.clientX - p2.clientX;\r\n    var dy = p1.clientY - p2.clientY;\r\n    return {\r\n        dx: dx,\r\n        dy: dy,\r\n        deg: Math.atan2(dy, dx) / Math.PI * 180,\r\n        length: Math.sqrt(dx * dx + dy * dy)\r\n    };\r\n}\r\n\r\nfunction textInputAllowed(v) {\r\n    return v.isContentEditable || is(v, 'input,textarea,select');\r\n}\r\n\r\nfunction getScrollParent(element) {\r\n    for (var s; element !== root && (s = getComputedStyle(element)) && s.overflow === 'visible' && matchWord(s.position, 'static relative'); element = element.parentNode);\r\n    return element;\r\n}\r\n\r\nfunction getUnobscuredRect(element) {\r\n    var style = getComputedStyle(element);\r\n    var hasOverflowX = element.offsetWidth < element.scrollWidth;\r\n    var hasOverflowY = element.offsetHeight < element.scrollHeight;\r\n    var parentRect = getRect(element === document.body ? root : element);\r\n    if ((style.overflow !== 'visible' || element === document.body) && (hasOverflowX || hasOverflowY)) {\r\n        if (style.overflowY === 'scroll' || ((style.overflowY !== 'hidden' || element === document.body) && hasOverflowY)) {\r\n            parentRect.right -= scrollbarWidth;\r\n        }\r\n        if (style.overflowX === 'scroll' || ((style.overflowX !== 'hidden' || element === document.body) && hasOverflowX)) {\r\n            parentRect.bottom -= scrollbarWidth;\r\n        }\r\n    }\r\n    return parentRect;\r\n}\r\n\r\nfunction scrollIntoView(element, rect) {\r\n    var parent = getScrollParent(element);\r\n    var parentRect = getUnobscuredRect(parent);\r\n    rect = rect || getRect(element);\r\n\r\n    var deltaX = Math.max(0, rect.right - parentRect.right) || Math.min(rect.left - parentRect.left, 0);\r\n    var deltaY = Math.max(0, rect.bottom - parentRect.bottom) || Math.min(rect.top - parentRect.top, 0);\r\n    var result = (deltaX || deltaY) && scrollBy(parent, deltaX, deltaY) || OFFSET_ZERO;\r\n    if (parent !== root) {\r\n        var parentResult = scrollIntoView(parent.parentNode, rect.translate(result.x, result.y));\r\n        if (parentResult) {\r\n            result = {\r\n                x: result.x + parentResult.x,\r\n                y: result.y + parentResult.y\r\n            };\r\n        }\r\n    }\r\n    return (result.x || result.y) ? result : false;\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Focus management\r\n * -------------------------------------- */\r\n\r\nfunction focused(element, strict) {\r\n    // @ts-ignore: activeElement is not null\r\n    return element === window ? !windowFocusedOut : focusElements.has(element) && (!strict || containsOrEquals(element, document.activeElement));\r\n}\r\n\r\nfunction focusable(element) {\r\n    var friends = map(parentsAndSelf(element), function (v) {\r\n        return focusFriends.get(v);\r\n    });\r\n    return any(focusPath, function (v) {\r\n        return containsOrEquals(v, element) || friends.indexOf(v) >= 0;\r\n    });\r\n}\r\n\r\nfunction focusLockedWithin(element) {\r\n    return single(modalElements, function (v, i) {\r\n        return $(v).find(element)[0] && i;\r\n    });\r\n}\r\n\r\nfunction triggerFocusEvent(eventName, elements, relatedTarget, source) {\r\n    each(elements, function (i, v) {\r\n        if (getContainer(v, true)) {\r\n            emitDOMEvent(eventName, null, v, {\r\n                relatedTarget: relatedTarget\r\n            }, false, source);\r\n        }\r\n    });\r\n}\r\n\r\nfunction setFocus(element, focusOnInput, source, path) {\r\n    if (focusOnInput && !is(element, SELECTOR_FOCUSABLE)) {\r\n        element = $(SELECTOR_FOCUSABLE, element).filter(':visible:not(:disabled,.disabled)')[0] || element;\r\n    }\r\n    path = path || focusPath;\r\n    if (path[0]) {\r\n        var within = path !== focusPath ? element : focusable(element);\r\n        if (!within) {\r\n            var lockParent = focusLockedWithin(element);\r\n            element = focused(lockParent) ? path[0] : lockParent;\r\n            within = focusable(element);\r\n        }\r\n        if (!within) {\r\n            return false;\r\n        }\r\n        var removed = path.splice(0, path.indexOf(within));\r\n        each(removed, function (i, v) {\r\n            focusElements.delete(v);\r\n        });\r\n        triggerFocusEvent('focusout', removed, element, source);\r\n    }\r\n    // check whether the element is still attached in ROM\r\n    // which can be detached while dispatching focusout event above\r\n    if (containsOrEquals(root, element)) {\r\n        var added = parentsAndSelf(element).filter(function (v) {\r\n            return !focusElements.has(v);\r\n        });\r\n        var friend = map(added, function (v) {\r\n            return focusFriends.get(v);\r\n        })[0];\r\n        if (friend && !focused(friend)) {\r\n            var result = setFocus(friend);\r\n            if (result !== undefined) {\r\n                return result && setFocus(element);\r\n            }\r\n        }\r\n        if (added[0]) {\r\n            path.unshift.apply(path, added);\r\n            each(added, function (i, v) {\r\n                focusElements.add(v);\r\n            });\r\n            triggerFocusEvent('focusin', added, null, source || new ZetaEventSource(added[0], path));\r\n        }\r\n        var activeElement = document.activeElement;\r\n        if (path[0] !== activeElement) {\r\n            path[0].focus();\r\n            // ensure previously focused element is properly blurred\r\n            // in case the new element is not focusable\r\n            if (activeElement && activeElement !== document.body && activeElement !== root && document.activeElement === activeElement) {\r\n                // @ts-ignore: activeElement is HTMLElement\r\n                activeElement.blur();\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction setModal(element, within) {\r\n    var focusWithin = is(within, Node) || root;\r\n    if (!focused(focusWithin)) {\r\n        setFocus(focusWithin);\r\n    }\r\n    modalElements.set(element, focusPath.splice(0, focusWithin === root || document.body ? focusPath.length : focusPath.indexOf(focusWithin)));\r\n    setFocus(element);\r\n}\r\n\r\nfunction retainFocus(a, b) {\r\n    focusFriends.set(b, a);\r\n}\r\n\r\nfunction releaseFocus(b) {\r\n    focusFriends.delete(b);\r\n}\r\n\r\n\r\n/* --------------------------------------\r\n * Observe\r\n * -------------------------------------- */\r\n\r\nfunction watchElements(element, selector, callback) {\r\n    var collection = new Set();\r\n    var observer = new MutationObserver(function (records) {\r\n        var removedNodes = map(records, function (v) {\r\n            return selectIncludeSelf(selector, v.removedNodes);\r\n        });\r\n        var addedNodes = map(records, function (v) {\r\n            return selectIncludeSelf(selector, v.addedNodes);\r\n        });\r\n        addedNodes = addedNodes.filter(function (v) {\r\n            return containsOrEquals(element, v) && !collection.has(v);\r\n        });\r\n        removedNodes = removedNodes.filter(function (v) {\r\n            return !containsOrEquals(element, v);\r\n        });\r\n        addedNodes.forEach(collection.add.bind(collection));\r\n        removedNodes.forEach(collection.delete.bind(collection));\r\n        callback(addedNodes, removedNodes);\r\n    });\r\n    observer.observe(element, {\r\n        subtree: true,\r\n        childList: true\r\n    });\r\n}\r\n\r\n/* --------------------------------------\r\n * DOM event handling\r\n * -------------------------------------- */\r\n\r\n\r\ndomReady.then(function () {\r\n    var body = document.body;\r\n    var modifierCount;\r\n    var modifiedKeyCode;\r\n    var mouseInitialPoint;\r\n    var mousedownFocus;\r\n    var pressTimeout;\r\n    var imeNode;\r\n    var imeOffset;\r\n    var imeText;\r\n    \r\n    // detect native scrollbar size\r\n    // height being picked because scrollbar may not be shown if container is too short\r\n    var dummy = $('<div style=\"overflow:scroll;height:80px\"><div style=\"height:100px\"></div></div>').appendTo(body)[0];\r\n    scrollbarWidth = getRect(dummy).width - getRect(dummy.children[0]).width;\r\n    removeNode(dummy);\r\n\r\n    function getEventName(e, suffix) {\r\n        var mod = ((e.ctrlKey || e.metaKey) ? 'Ctrl' : '') + (e.altKey ? 'Alt' : '') + (e.shiftKey ? 'Shift' : '');\r\n        return mod ? lcfirst(mod + ucfirst(suffix)) : suffix;\r\n    }\r\n\r\n    function updateIMEState() {\r\n        var element = document.activeElement || root;\r\n        if ('selectionEnd' in element) {\r\n            imeNode = element;\r\n            // @ts-ignore: guranteed having selectionEnd property\r\n            imeOffset = element.selectionEnd;\r\n        } else {\r\n            // @ts-ignore: selection is not null\r\n            imeNode = selection.anchorNode;\r\n            // @ts-ignore: selection is not null\r\n            imeOffset = selection.anchorOffset;\r\n            if (imeNode && imeNode.nodeType === 1) {\r\n                // IE puts selection at element level\r\n                // however it will insert text in the previous text node\r\n                var child = imeNode.childNodes[imeOffset - 1];\r\n                if (child && child.nodeType === 3) {\r\n                    imeNode = child;\r\n                    // @ts-ignore: child is Text\r\n                    imeOffset = child.length;\r\n                } else {\r\n                    imeNode = imeNode.childNodes[imeOffset];\r\n                    imeOffset = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function triggerUIEvent(eventName, nativeEvent, elements, data, bubbles) {\r\n        var prev = null;\r\n        return any(makeArray(elements), function (v) {\r\n            var container = getContainer(v);\r\n            if (prev !== container) {\r\n                prev = container;\r\n                if (emitDOMEvent(eventName, nativeEvent, v, data, bubbles)) {\r\n                    return true;\r\n                }\r\n                if (data.char && textInputAllowed(v)) {\r\n                    return emitDOMEvent('textInput', nativeEvent, v, data.char, true);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    function triggerKeystrokeEvent(keyName, char, nativeEvent) {\r\n        var data = {\r\n            data: keyName,\r\n            char: char\r\n        };\r\n        lastEventSource.sourceKeyName = keyName;\r\n        if (triggerUIEvent('keystroke', nativeEvent, focusPath, data, true)) {\r\n            nativeEvent.preventDefault();\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function triggerMouseEvent(eventName, nativeEvent) {\r\n        var point = mouseInitialPoint || nativeEvent;\r\n        return emitDOMEvent(eventName, nativeEvent, nativeEvent.target, {\r\n            target: nativeEvent.target,\r\n            clientX: point.clientX,\r\n            clientY: point.clientY,\r\n            metakey: getEventName(nativeEvent)\r\n        });\r\n    }\r\n\r\n    function triggerGestureEvent(gesture, nativeEvent) {\r\n        mouseInitialPoint = null;\r\n        return triggerUIEvent('gesture', nativeEvent, focusPath.slice(-1), gesture);\r\n    }\r\n\r\n    function unmount(mutations) {\r\n        // automatically free resources when DOM nodes are removed from document\r\n        each(mutations, function (i, v) {\r\n            each(v.removedNodes, function (i, v) {\r\n                if (v.nodeType === 1 && !containsOrEquals(root, v)) {\r\n                    var container = getContainer(v, true);\r\n                    if (container && container.autoDestroy && container.element === v) {\r\n                        container.destroy();\r\n                    }\r\n                    removeLock(v);\r\n                    var modalPath = mapRemove(modalElements, v);\r\n                    if (modalPath && focused(v)) {\r\n                        var path = any(modalElements, function (w) {\r\n                            return w.indexOf(v) >= 0;\r\n                        }) || focusPath;\r\n                        path.push.apply(path, modalPath);\r\n                        setFocus(modalPath[0], false, null, path);\r\n                    }\r\n                    var index = focusPath.indexOf(v);\r\n                    if (index >= 0) {\r\n                        setFocus(focusPath[index + 1] || body);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    if (IS_IE10) {\r\n        // polyfill for pointer-events: none for IE10\r\n        bind(body, 'mousedown mouseup mousemove mouseenter mouseleave click dblclick contextmenu wheel', function (e) {\r\n            // @ts-ignore: e.target is Element\r\n            if (getComputedStyle(e.target).pointerEvents === 'none') {\r\n                e.stopPropagation();\r\n                e.stopImmediatePropagation();\r\n                // @ts-ignore: e.target is Element\r\n                if (!e.bubbles || !dispatchDOMMouseEvent(e.type, e, e)) {\r\n                    e.preventDefault();\r\n                }\r\n            }\r\n        }, true);\r\n    }\r\n\r\n    bind(window, 'mousedown mouseup wheel compositionstart compositionend beforeinput textInput keydown keyup keypress touchstart touchend cut copy paste drop click dblclick contextmenu', function (e) {\r\n        currentEvent = e;\r\n        setTimeout(function () {\r\n            currentEvent = null;\r\n        });\r\n        setLastEventSource(null);\r\n        if (!focusable(e.target)) {\r\n            e.stopImmediatePropagation();\r\n            e.preventDefault();\r\n            if (matchWord(e.type, 'touchstart mousedown keydown')) {\r\n                emitDOMEvent('focusreturn', null, focusPath.slice(-1)[0]);\r\n            }\r\n        }\r\n        setLastEventSource(e.target);\r\n    }, true);\r\n\r\n    bind(root, {\r\n        compositionstart: function () {\r\n            updateIMEState();\r\n            imeText = '';\r\n        },\r\n        compositionupdate: function (e) {\r\n            imeText = e.data;\r\n        },\r\n        compositionend: function (e) {\r\n            var isInputElm = 'selectionEnd' in imeNode;\r\n            var prevText = imeText;\r\n            var prevOffset = imeOffset;\r\n            updateIMEState();\r\n\r\n            var curText = imeNode.value || imeNode.data || '';\r\n            imeText = e.data;\r\n            // some IME lacks inserted character sequence when selecting from phrase candidate list\r\n            // also legacy Microsoft Changjie IME reports full-width spaces (U+3000) instead of actual characters\r\n            if (!imeText || /^\\u3000+$/.test(imeText)) {\r\n                imeText = curText.slice(prevOffset, imeOffset);\r\n            }\r\n\r\n            // some old mobile browsers fire compositionend event before replacing final character sequence\r\n            // need to compare both to truncate the correct range of characters\r\n            // three cases has been observed: XXX{imeText}|, XXX{prevText}| and XXX|{imeText}\r\n            var o1 = imeOffset - imeText.length;\r\n            var o2 = imeOffset - prevText.length;\r\n            var startOffset = imeOffset;\r\n            if (curText.slice(o1, imeOffset) === imeText) {\r\n                startOffset = o1;\r\n            } else if (curText.slice(o2, imeOffset) === prevText) {\r\n                startOffset = o2;\r\n            } else if (curText.substr(imeOffset, imeText.length) === imeText) {\r\n                imeOffset += imeText.length;\r\n            }\r\n            var newText = curText.substr(0, startOffset) + curText.slice(imeOffset);\r\n            if (isInputElm) {\r\n                imeNode.value = newText;\r\n                imeNode.setSelectionRange(startOffset, startOffset);\r\n            } else {\r\n                imeNode.data = newText;\r\n                makeSelection(imeNode, startOffset);\r\n            }\r\n            if (!triggerUIEvent('textInput', e, focusPath[0], imeText)) {\r\n                if (isInputElm) {\r\n                    imeNode.value = curText;\r\n                    imeNode.setSelectionRange(imeOffset, imeOffset);\r\n                } else {\r\n                    imeNode.data = curText;\r\n                    makeSelection(imeNode, imeOffset);\r\n                }\r\n            }\r\n            imeNode = null;\r\n            setTimeout(function () {\r\n                imeText = null;\r\n            });\r\n        },\r\n        textInput: function (e) {\r\n            // required for older mobile browsers that do not support beforeinput event\r\n            // ignore in case browser fire textInput before/after compositionend\r\n            if (!imeNode && (e.data === imeText || triggerUIEvent('textInput', e, focusPath[0], e.data))) {\r\n                e.preventDefault();\r\n            }\r\n        },\r\n        keydown: function (e) {\r\n            if (!imeNode) {\r\n                var keyCode = e.keyCode;\r\n                var isModifierKey = (META_KEYS.indexOf(keyCode) >= 0);\r\n                if (isModifierKey && keyCode !== modifiedKeyCode) {\r\n                    triggerUIEvent('metakeychange', e, focusPath, getEventName(e), true);\r\n                }\r\n                var isSpecialKey = !isModifierKey && (KEYNAMES[keyCode] || '').length > 1 && !(keyCode >= 186 || (keyCode >= 96 && keyCode <= 111));\r\n                // @ts-ignore: boolean arithmetic\r\n                modifierCount = e.ctrlKey + e.shiftKey + e.altKey + e.metaKey + !isModifierKey;\r\n                // @ts-ignore: boolean arithmetic\r\n                modifierCount *= isSpecialKey || ((modifierCount > 2 || (modifierCount > 1 && !e.shiftKey)) && !isModifierKey);\r\n                modifiedKeyCode = keyCode;\r\n                if (modifierCount) {\r\n                    triggerKeystrokeEvent(getEventName(e, KEYNAMES[keyCode] || e.key), keyCode === 32 ? ' ' : '', e);\r\n                }\r\n            }\r\n        },\r\n        keyup: function (e) {\r\n            var isModifierKey = (META_KEYS.indexOf(e.keyCode) >= 0);\r\n            if (!imeNode && (isModifierKey || modifiedKeyCode === e.keyCode)) {\r\n                modifiedKeyCode = null;\r\n                modifierCount--;\r\n                if (isModifierKey) {\r\n                    triggerUIEvent('metakeychange', e, focusPath, getEventName(e) || '', true);\r\n                }\r\n            }\r\n        },\r\n        keypress: function (e) {\r\n            var data = e.char || e.key || String.fromCharCode(e.charCode);\r\n            // @ts-ignore: non-standard member\r\n            if (!imeNode && !modifierCount && (e.synthetic || !('onbeforeinput' in e.target))) {\r\n                triggerKeystrokeEvent(getEventName(e, KEYNAMES[modifiedKeyCode] || data), data, e);\r\n            }\r\n        },\r\n        beforeinput: function (e) {\r\n            if (!imeNode && e.cancelable) {\r\n                switch (e.inputType) {\r\n                    case 'insertText':\r\n                        return triggerUIEvent('textInput', e, focusPath[0], e.data);\r\n                    case 'deleteContent':\r\n                    case 'deleteContentBackward':\r\n                        return triggerKeystrokeEvent('backspace', '', e);\r\n                    case 'deleteContentForward':\r\n                        return triggerKeystrokeEvent('delete', '', e);\r\n                }\r\n            }\r\n        },\r\n        touchstart: function (e) {\r\n            mouseInitialPoint = extend({}, e.touches[0]);\r\n            if (!e.touches[1]) {\r\n                // @ts-ignore: e.target is Element\r\n                if (focused(getContainer(e.target).element)) {\r\n                    triggerMouseEvent('mousedown', e);\r\n                }\r\n                pressTimeout = setTimeout(function () {\r\n                    if (mouseInitialPoint) {\r\n                        triggerMouseEvent('longPress', e);\r\n                        mouseInitialPoint = null;\r\n                    }\r\n                }, 1000);\r\n            }\r\n        },\r\n        touchmove: function (e) {\r\n            clearTimeout(pressTimeout);\r\n            pressTimeout = null;\r\n            if (mouseInitialPoint) {\r\n                if (!e.touches[1]) {\r\n                    var line = measureLine(e.touches[0], mouseInitialPoint);\r\n                    if (line.length > 50 && approxMultipleOf(line.deg, 90)) {\r\n                        triggerGestureEvent('swipe' + (approxMultipleOf(line.deg, 180) ? (line.dx > 0 ? 'Right' : 'Left') : (line.dy > 0 ? 'Bottom' : 'Top')), e);\r\n                    }\r\n                } else if (!e.touches[2]) {\r\n                    triggerGestureEvent('pinchZoom', e);\r\n                }\r\n            }\r\n        },\r\n        touchend: function (e) {\r\n            clearTimeout(pressTimeout);\r\n            if (mouseInitialPoint && pressTimeout) {\r\n                setFocus(e.target);\r\n                triggerMouseEvent('click', e);\r\n                dispatchDOMMouseEvent('click', mouseInitialPoint, e);\r\n                e.preventDefault();\r\n            }\r\n        },\r\n        mousedown: function (e) {\r\n            setFocus(e.target);\r\n            if ((e.buttons || e.which) === 1) {\r\n                triggerMouseEvent('mousedown', e);\r\n            }\r\n            mouseInitialPoint = e;\r\n            mousedownFocus = document.activeElement;\r\n        },\r\n        mousemove: function (e) {\r\n            if (mouseInitialPoint && measureLine(e, mouseInitialPoint).length > 5) {\r\n                mouseInitialPoint = null;\r\n            }\r\n        },\r\n        mouseup: function () {\r\n            if (mousedownFocus && document.activeElement !== mousedownFocus) {\r\n                mousedownFocus.focus();\r\n            }\r\n        },\r\n        wheel: function (e) {\r\n            // @ts-ignore: e.target is Element\r\n            if (containsOrEquals(e.target, focusPath[0]) || !textInputAllowed(e.target)) {\r\n                var dir = e.deltaY || e.detail;\r\n                if (dir && triggerUIEvent('mousewheel', e, e.target, dir / Math.abs(dir) * (IS_MAC ? -1 : 1), true)) {\r\n                    e.preventDefault();\r\n                }\r\n            }\r\n        },\r\n        click: function (e) {\r\n            if (!IS_TOUCH && mouseInitialPoint) {\r\n                triggerMouseEvent('click', e);\r\n            }\r\n        },\r\n        contextmenu: function (e) {\r\n            triggerMouseEvent('rightClick', e);\r\n        },\r\n        dblclick: function (e) {\r\n            triggerMouseEvent('dblclick', e);\r\n        },\r\n        focusin: function (e) {\r\n            windowFocusedOut = false;\r\n            if (focusable(e.target)) {\r\n                setFocus(e.target, false, lastEventSource);\r\n            } else {\r\n                // @ts-ignore: e.target is Element\r\n                e.target.blur();\r\n            }\r\n        },\r\n        focusout: function (e) {\r\n            // browser set focus to body if the focused element is no longer visible\r\n            // which is not a desirable behavior in many cases\r\n            // find the first visible element in focusPath to focus\r\n            // @ts-ignore: e.target is Element\r\n            if (!e.relatedTarget && !isVisible(e.target)) {\r\n                var cur = any(focusPath.slice(focusPath.indexOf(e.target) + 1), isVisible);\r\n                if (cur) {\r\n                    setFocus(cur, false, lastEventSource);\r\n                }\r\n            }\r\n        }\r\n    }, true);\r\n\r\n    bind(window, {\r\n        wheel: function (e) {\r\n            // scrolling will happen on first scrollable element up the DOM tree\r\n            // prevent scrolling if interaction on such element should be blocked by modal element\r\n            var deltaX = -e.deltaX;\r\n            var deltaY = -e.deltaY;\r\n            // @ts-ignore: e.target is Element\r\n            for (var cur = e.target; cur && cur !== root; cur = cur.parentNode) {\r\n                // @ts-ignore: e.target is Element\r\n                var style = getComputedStyle(cur);\r\n                // @ts-ignore: e.target is Element\r\n                if (cur.scrollWidth > cur.offsetWidth && matchWord(style.overflowX, 'auto scroll') && ((deltaX > 0 && cur.scrollLeft > 0) || (deltaX < 0 && cur.scrollLeft + cur.offsetWidth < cur.scrollWidth))) {\r\n                    break;\r\n                }\r\n                // @ts-ignore: e.target is Element\r\n                if (cur.scrollHeight > cur.offsetHeight && matchWord(style.overflowY, 'auto scroll') && ((deltaY > 0 && cur.scrollTop > 0) || (deltaY < 0 && cur.scrollTop + cur.offsetHeight < cur.scrollHeight))) {\r\n                    break;\r\n                }\r\n            }\r\n            if (!focusable(cur)) {\r\n                e.preventDefault();\r\n            }\r\n        },\r\n        blur: function (e) {\r\n            if (e.target === window) {\r\n                windowFocusedOut = true;\r\n            }\r\n        }\r\n    });\r\n\r\n    new MutationObserver(unmount).observe(root, {\r\n        subtree: true,\r\n        childList: true\r\n    });\r\n    setFocus(document.activeElement);\r\n});\r\n\r\n\r\n/* --------------------------------------\r\n * Exports\r\n * -------------------------------------- */\r\n\r\nexport default {\r\n    get event() {\r\n        return currentEvent;\r\n    },\r\n    get activeElement() {\r\n        return focusPath[0];\r\n    },\r\n    get focusedElements() {\r\n        return focusPath.slice(0);\r\n    },\r\n    get eventSource() {\r\n        return getEventSource();\r\n    },\r\n    root,\r\n    ready: domReady,\r\n\r\n    focusable,\r\n    focused,\r\n    setModal,\r\n    setFocus,\r\n    retainFocus,\r\n    releaseFocus,\r\n    focus: function (element) {\r\n        setFocus(element, true);\r\n    },\r\n\r\n    getEventSource,\r\n    on: listenDOMEvent,\r\n    emit: function (eventName, element, data, bubbles) {\r\n        return emitDOMEvent(eventName, null, element, data, bubbles);\r\n    },\r\n\r\n    lock,\r\n    locked,\r\n    cancelLock,\r\n    removeLock,\r\n\r\n    scrollIntoView,\r\n    watchElements,\r\n};\r\n","import * as env from \"./env.js\";\r\nimport * as shim from \"./shim.js\";\r\nimport * as _util from \"./util.js\";\r\nimport * as _domUtil from \"./domUtil.js\";\r\nimport * as cssUtil from \"./cssUtil.js\";\r\nimport dom from \"./dom.js\";\r\n\r\nconst IS_IOS = env.IS_IOS;\r\nconst IS_IE10 = env.IS_IE10;\r\nconst IS_IE = env.IS_IE;\r\nconst IS_MAC = env.IS_MAC;\r\nconst IS_TOUCH = env.IS_TOUCH;\r\nconst util = { ..._util, ..._domUtil };\r\n\r\nexport default {\r\n    IS_IOS,\r\n    IS_IE10,\r\n    IS_IE,\r\n    IS_MAC,\r\n    IS_TOUCH,\r\n    shim,\r\n    util,\r\n    dom,\r\n    css: cssUtil\r\n};\r\n\r\nexport {\r\n    IS_IOS,\r\n    IS_IE10,\r\n    IS_IE,\r\n    IS_MAC,\r\n    IS_TOUCH,\r\n    shim,\r\n    util,\r\n    dom,\r\n    cssUtil as css\r\n};\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__804__;","module.exports = __WEBPACK_EXTERNAL_MODULE__44__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(463);\n"],"sourceRoot":""}